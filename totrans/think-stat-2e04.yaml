- en: Chapter 3  Probability mass functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://greenteapress.com/thinkstats2/html/thinkstats2004.html](https://greenteapress.com/thinkstats2/html/thinkstats2004.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code for this chapter is in `probability.py`. For information about downloading
    and working with this code, see Section [0.2](thinkstats2001.html#code).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1  Pmfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to represent a distribution is a probability mass function (PMF),
    which maps from each value to its probability. A probability is a frequency expressed
    as a fraction of the sample size, `n`. To get from frequencies to probabilities,
    we divide through by `n`, which is called normalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a Hist, we can make a dictionary that maps from each value to its probability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use the Pmf class provided by `thinkstats2`. Like Hist, the Pmf constructor
    can take a list, pandas Series, dictionary, Hist, or another Pmf object. Here’s
    an example with a simple list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Pmf is normalized so total probability is 1.
  prefs: []
  type: TYPE_NORMAL
- en: Pmf and Hist objects are similar in many ways; in fact, they inherit many of
    their methods from a common parent class. For example, the methods `Values` and
    `Items` work the same way for both. The biggest difference is that a Hist maps
    from values to integer counters; a Pmf maps from values to floating-point probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look up the probability associated with a value, use `Prob`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The bracket operator is equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can modify an existing Pmf by incrementing the probability associated with
    a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can multiply a probability by a factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you modify a Pmf, the result may not be normalized; that is, the probabilities
    may no longer add up to 1\. To check, you can call `Total`, which returns the
    sum of the probabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To renormalize, call `Normalize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Pmf objects provide a `Copy` method so you can make and modify a copy without
    affecting the original.
  prefs: []
  type: TYPE_NORMAL
- en: 'My notation in this section might seem inconsistent, but there is a system:
    I use Pmf for the name of the class, `pmf` for an instance of the class, and PMF
    for the mathematical concept of a probability mass function.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2  Plotting PMFs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`thinkplot` provides two ways to plot Pmfs:'
  prefs: []
  type: TYPE_NORMAL
- en: To plot a Pmf as a bar graph, you can use `thinkplot.Hist`. Bar graphs are most
    useful if the number of values in the Pmf is small.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To plot a Pmf as a step function, you can use `thinkplot.Pmf`. This option is
    most useful if there are a large number of values and the Pmf is smooth. This
    function also works with Hist objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, `pyplot` provides a function called `hist` that takes a sequence
    of values, computes a histogram, and plots it. Since I use Hist objects, I usually
    don’t use `pyplot.hist`.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/50dde81615cd97e97b518bcbaa2b4559.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Figure 3.1: PMF of pregnancy lengths for first babies and others, using bar
    graphs and step functions. |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure [3.1](#probability_nsfg_pmf) shows PMFs of pregnancy length for first
    babies and others using bar graphs (left) and step functions (right).
  prefs: []
  type: TYPE_NORMAL
- en: By plotting the PMF instead of the histogram, we can compare the two distributions
    without being misled by the difference in sample size. Based on this figure, first
    babies seem to be less likely than others to arrive on time (week 39) and more
    likely to be a late (weeks 41 and 42).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code that generates Figure [3.1](#probability_nsfg_pmf):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`PrePlot` takes optional parameters `rows` and `cols` to make a grid of figures,
    in this case one row of two figures. The first figure (on the left) displays the
    Pmfs using `thinkplot.Hist`, as we have seen before.'
  prefs: []
  type: TYPE_NORMAL
- en: The second call to `PrePlot` resets the color generator. Then `SubPlot` switches
    to the second figure (on the right) and displays the Pmfs using `thinkplot.Pmfs`.
    I used the `axis` option to ensure that the two figures are on the same axes,
    which is generally a good idea if you intend to compare two figures.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3  Other visualizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Histograms and PMFs are useful while you are exploring data and trying to identify
    patterns and relationships. Once you have an idea what is going on, a good next
    step is to design a visualization that makes the patterns you have identified
    as clear as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the NSFG data, the biggest differences in the distributions are near the
    mode. So it makes sense to zoom in on that part of the graph, and to transform
    the data to emphasize differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, `weeks` is the range of weeks; `diffs` is the difference between
    the two PMFs in percentage points. Figure [3.2](#probability_nsfg_diffs) shows
    the result as a bar chart. This figure makes the pattern clearer: first babies
    are less likely to be born in week 39, and somewhat more likely to be born in
    weeks 41 and 42.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/f9f39ebe856b5c86bcaa2e9383e5e323.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Figure 3.2: Difference, in percentage points, by week. |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For now we should hold this conclusion only tentatively. We used the same dataset
    to identify an apparent difference and then chose a visualization that makes the
    difference apparent. We can’t be sure this effect is real; it might be due to
    random variation. We’ll address this concern later.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4  The class size paradox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we go on, I want to demonstrate one kind of computation you can do with
    Pmf objects; I call this example the “class size paradox.”
  prefs: []
  type: TYPE_NORMAL
- en: 'At many American colleges and universities, the student-to-faculty ratio is
    about 10:1\. But students are often surprised to discover that their average class
    size is bigger than 10\. There are two reasons for the discrepancy:'
  prefs: []
  type: TYPE_NORMAL
- en: Students typically take 4–5 classes per semester, but professors often teach
    1 or 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of students who enjoy a small class is small, but the number of students
    in a large class is (ahem!) large.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first effect is obvious, at least once it is pointed out; the second is
    more subtle. Let’s look at an example. Suppose that a college offers 65 classes
    in a given semester, with the following distribution of sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ask the Dean for the average class size, he would construct a PMF, compute
    the mean, and report that the average class size is 23.7\. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But if you survey a group of students, ask them how many students are in their
    classes, and compute the mean, you would think the average class was bigger. Let’s
    see how much bigger.
  prefs: []
  type: TYPE_NORMAL
- en: First, I compute the distribution as observed by students, where the probability
    associated with each class size is “biased” by the number of students in the class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For each class size, `x`, we multiply the probability by `x`, the number of
    students who observe that class size. The result is a new Pmf that represents
    the biased distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can plot the actual and observed distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/5d78ccbc6ace158772b3a12ef6f92261.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Figure 3.3: Distribution of class sizes, actual and as observed by students.
    |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Figure [3.3](#class_size1) shows the result. In the biased distribution there
    are fewer small classes and more large ones. The mean of the biased distribution
    is 29.1, almost 25% higher than the actual mean.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to invert this operation. Suppose you want to find the distribution
    of class sizes at a college, but you can’t get reliable data from the Dean. An
    alternative is to choose a random sample of students and ask how many students
    are in their classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result would be biased for the reasons we’ve just seen, but you can use
    it to estimate the actual distribution. Here’s the function that unbiases a Pmf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It’s similar to `BiasPmf`; the only difference is that it divides each probability
    by `x` instead of multiplying.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5  DataFrame indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Section [1.4](thinkstats2002.html#dataframe) we read a pandas DataFrame
    and used it to select and modify data columns. Now let’s look at row selection.
    To start, I create a NumPy array of random numbers and use it to initialize a
    DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the rows and columns are numbered starting at zero, but you can
    provide column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can also provide row names. The set of row names is called the index; the
    row names themselves are called labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in the previous chapter, simple indexing selects a column, returning
    a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To select a row by label, you can use the `loc` attribute, which returns a
    Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you know the integer position of a row, rather than its label, you can use
    the `iloc` attribute, which also returns a Series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`loc` can also take a list of labels; in that case, the result is a DataFrame.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use a slice to select a range of rows by label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Or by integer position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The result in either case is a DataFrame, but notice that the first result includes
    the end of the slice; the second doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'My advice: if your rows have labels that are not simple integers, use the labels
    consistently and avoid using integer positions.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.6  Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Solutions to these exercises are in `chap03soln.ipynb` and `chap03soln.py`
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1   *Something like the class size paradox appears if you survey children
    and ask how many children are in their family. Families with many children are
    more likely to appear in your sample, and families with no children have no chance
    to be in the sample.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Use the NSFG respondent variable `NUMKDHH` to construct the actual distribution
    for the number of children under 18 in the household.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Now compute the biased distribution we would see if we surveyed the children
    and asked them how many children under 18 (including themselves) are in their
    household.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Plot the actual and biased distributions, and compute their means. As a starting
    place, you can use `chap03ex.ipynb`.*'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs: []
  type: TYPE_NORMAL
- en: '*In Section *[*2.7*](thinkstats2003.html#mean) *we computed the mean of a sample
    by adding up the elements and dividing by n. If you are given a PMF, you can still
    compute the mean, but the process is slightly different:*'
  prefs: []
  type: TYPE_NORMAL
- en: '| x =  |'
  prefs: []
  type: TYPE_TB
- en: '&#124;   &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ∑ &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; i &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|  p[i] x[i]  |'
  prefs: []
  type: TYPE_TB
- en: '*where the* x[i] *are the unique values in the PMF and* p[i]=PMF(x[i])*. Similarly,
    you can compute variance like this:*'
  prefs: []
  type: TYPE_NORMAL
- en: '| S² =  |'
  prefs: []
  type: TYPE_TB
- en: '&#124;   &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ∑ &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; i &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|  p[i] (x[i] − x)² |'
  prefs: []
  type: TYPE_TB
- en: '*Write functions called `PmfMean` and `PmfVar` that take a Pmf object and compute
    the mean and variance. To test these methods, check that they are consistent with
    the methods `Mean` and `Var` provided by Pmf.*'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3   *I started with the question, “Are first babies more likely to
    be late?” To address it, I computed the difference in means between groups of
    babies, but I ignored the possibility that there might be a difference between
    first babies and others* for the same woman*.*
  prefs: []
  type: TYPE_NORMAL
- en: '*To address this version of the question, select respondents who have at least
    two babies and compute pairwise differences. Does this formulation of the question
    yield a different result?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hint: use `nsfg.MakePregMap`.*'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4
  prefs: []
  type: TYPE_NORMAL
- en: '*In most foot races, everyone starts at the same time. If you are a fast runner,
    you usually pass a lot of people at the beginning of the race, but after a few
    miles everyone around you is going at the same speed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*When I ran a long-distance (209 miles) relay race for the first time, I noticed
    an odd phenomenon: when I overtook another runner, I was usually much faster,
    and when another runner overtook me, he was usually much faster.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*At first I thought that the distribution of speeds might be bimodal; that
    is, there were many slow runners and many fast runners, but few at my speed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Then I realized that I was the victim of a bias similar to the effect of class
    size. The race was unusual in two ways: it used a staggered start, so teams started
    at different times; also, many teams included runners at different levels of ability.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a result, runners were spread out along the course with little relationship
    between speed and location. When I joined the race, the runners near me were (pretty
    much) a random sample of the runners in the race.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*So where does the bias come from? During my time on the course, the chance
    of overtaking a runner, or being overtaken, is proportional to the difference
    in our speeds. I am more likely to catch a slow runner, and more likely to be
    caught by a fast runner. But runners at the same speed are unlikely to see each
    other.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Write a function called `ObservedPmf` that takes a Pmf representing the actual
    distribution of runners’ speeds, and the speed of a running observer, and returns
    a new Pmf representing the distribution of runners’ speeds as seen by the observer.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*To test your function, you can use `relay.py`, which reads the results from
    the James Joyce Ramble 10K in Dedham MA and converts the pace of each runner to
    mph.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Compute the distribution of speeds you would observe if you ran a relay race
    at 7.5 mph with this group of runners. A solution to this exercise is in `relay_soln.py`.*'
  prefs: []
  type: TYPE_NORMAL
- en: 3.7  Glossary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probability mass function (PMF): a representation of a distribution as a function
    that maps from values to probabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'probability: A frequency expressed as a fraction of the sample size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'normalization: The process of dividing a frequency by a sample size to get
    a probability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'index: In a pandas DataFrame, the index is a special column that contains the
    row labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
