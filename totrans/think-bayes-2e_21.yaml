- en: Conjugate Priors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkBayes2/chap18.html](https://allendowney.github.io/ThinkBayes2/chap18.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapters we have used grid approximations to solve a variety
    of problems. One of my goals has been to show that this approach is sufficient
    to solve many real-world problems. And I think it’s a good place to start because
    it shows clearly how the methods work.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we saw in the previous chapter, grid methods will only get you so
    far. As we increase the number of parameters, the number of points in the grid
    grows (literally) exponentially. With more than 3-4 parameters, grid methods become
    impractical.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the remaining three chapters, I will present three alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll use **conjugate priors** to speed up some of the computations
    we’ve already done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next chapter, I’ll present Markov chain Monte Carlo (MCMC) methods, which
    can solve problems with tens of parameters, or even hundreds, in a reasonable
    amount of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And in the last chapter we’ll use Approximate Bayesian Computation (ABC) for
    problems that are hard to model with simple distributions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll start with the World Cup problem.
  prefs: []
  type: TYPE_NORMAL
- en: The World Cup Problem Revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In <<_PoissonProcesses>>, we solved the World Cup problem using a Poisson process
    to model goals in a soccer game as random events that are equally likely to occur
    at any point during a game.
  prefs: []
  type: TYPE_NORMAL
- en: We used a gamma distribution to represent the prior distribution of \(\lambda\),
    the goal-scoring rate. And we used a Poisson distribution to compute the probability
    of \(k\), the number of goals scored.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a gamma object that represents the prior distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a grid approximation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the likelihood of scoring 4 goals for each possible value of `lam`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And here’s the update.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So far, this should be familiar. Now we’ll solve the same problem using the
    conjugate prior.
  prefs: []
  type: TYPE_NORMAL
- en: The Conjugate Prior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In <<_TheGammaDistribution>>, I presented three reasons to use a gamma distribution
    for the prior and said there was a fourth reason I would reveal later. Well, now
    is the time.
  prefs: []
  type: TYPE_NORMAL
- en: The other reason I chose the gamma distribution is that it is the “conjugate
    prior” of the Poisson distribution, so-called because the two distributions are
    connected or coupled, which is what “conjugate” means.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section I’ll explain *how* they are connected, but first I’ll show
    you the consequence of this connection, which is that there is a remarkably simple
    way to compute the posterior distribution.
  prefs: []
  type: TYPE_NORMAL
- en: However, in order to demonstrate it, we have to switch from the one-parameter
    version of the gamma distribution to the two-parameter version. Since the first
    parameter is called `alpha`, you might guess that the second parameter is called
    `beta`.
  prefs: []
  type: TYPE_NORMAL
- en: The following function takes `alpha` and `beta` and makes an object that represents
    a gamma distribution with those parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the prior distribution with `alpha=1.4` again and `beta=1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now I claim without proof that we can do a Bayesian update with `k` goals just
    by making a gamma distribution with parameters `alpha+k` and `beta+1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here’s how we update it with `k=4` goals in `t=1` game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After all the work we did with the grid, it might seem absurd that we can do
    a Bayesian update by adding two pairs of numbers. So let’s confirm that it works.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll make a `Pmf` with a discrete approximation of the posterior distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The following figure shows the result along with the posterior we computed using
    the grid algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell source Hide code cell source</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]</details> ![_images/39ff697e7662f79c15a8ae461ced3925ebe82de05318674e35232f7e65030af6.png](../Images/6eed57e32a4a8ae310cfa4205aaaacf9.png)'
  prefs: []
  type: TYPE_NORMAL
- en: They are the same other than small differences due to floating-point approximations.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: What the Actual?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how that works, we’ll write the PDF of the gamma prior and the
    PMF of the Poisson likelihood, then multiply them together, because that’s what
    the Bayesian update does. We’ll see that the result is a gamma distribution, and
    we’ll derive its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the PDF of the gamma prior, which is the probability density for each
    value of \(\lambda\), given parameters \(\alpha\) and \(\beta\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[\lambda^{\alpha-1} e^{-\lambda \beta}\]
  prefs: []
  type: TYPE_NORMAL
- en: I have omitted the normalizing factor; since we are planning to normalize the
    posterior distribution anyway, we don’t really need it.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose a team scores \(k\) goals in \(t\) games. The probability of this
    data is given by the PMF of the Poisson distribution, which is a function of \(k\)
    with \(\lambda\) and \(t\) as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: \[\lambda^k e^{-\lambda t}\]
  prefs: []
  type: TYPE_NORMAL
- en: Again, I have omitted the normalizing factor, which makes it clearer that the
    gamma and Poisson distributions have the same functional form. When we multiply
    them together, we can pair up the factors and add up the exponents. The result
    is the unnormalized posterior distribution,
  prefs: []
  type: TYPE_NORMAL
- en: \[\lambda^{\alpha-1+k} e^{-\lambda(\beta + t)}\]
  prefs: []
  type: TYPE_NORMAL
- en: which we can recognize as an unnormalized gamma distribution with parameters
    \(\alpha + k\) and \(\beta + t\).
  prefs: []
  type: TYPE_NORMAL
- en: 'This derivation provides insight into what the parameters of the posterior
    distribution mean: \(\alpha\) reflects the number of events that have occurred;
    \(\beta\) reflects the elapsed time.'
  prefs: []
  type: TYPE_NORMAL
- en: Binomial Likelihood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a second example, let’s look again at the Euro problem. When we solved it
    with a grid algorithm, we started with a uniform prior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We used the binomial distribution to compute the likelihood of the data, which
    was 140 heads out of 250 attempts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then we computed the posterior distribution in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <details class="hide below-input"><summary aria-label="Toggle hidden content">Show
    code cell output Hide code cell output</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: We can solve this problem more efficiently using the conjugate prior of the
    binomial distribution, which is the beta distribution.
  prefs: []
  type: TYPE_NORMAL
- en: The beta distribution is bounded between 0 and 1, so it works well for representing
    the distribution of a probability like `x`. It has two parameters, called `alpha`
    and `beta`, that determine the shape of the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: SciPy provides an object called `beta` that represents a beta distribution.
    The following function takes `alpha` and `beta` and returns a new `beta` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that the uniform distribution, which we used as a prior, is the
    beta distribution with parameters `alpha=1` and `beta=1`. So we can make a `beta`
    object that represents a uniform distribution, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s figure out how to do the update. As in the previous example, we’ll
    write the PDF of the prior distribution and the PMF of the likelihood function,
    and multiply them together. We’ll see that the product has the same form as the
    prior, and we’ll derive its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the PDF of the beta distribution, which is a function of \(x\) with
    \(\alpha\) and \(\beta\) as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: \[x^{\alpha-1} (1-x)^{\beta-1}\]
  prefs: []
  type: TYPE_NORMAL
- en: Again, I have omitted the normalizing factor, which we don’t need because we
    are going to normalize the distribution after the update.
  prefs: []
  type: TYPE_NORMAL
- en: And here’s the PMF of the binomial distribution, which is a function of \(k\)
    with \(n\) and \(x\) as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: \[x^{k} (1-x)^{n-k}\]
  prefs: []
  type: TYPE_NORMAL
- en: Again, I have omitted the normalizing factor. Now when we multiply the beta
    prior and the binomial likelihood, the result is
  prefs: []
  type: TYPE_NORMAL
- en: \[x^{\alpha-1+k} (1-x)^{\beta-1+n-k}\]
  prefs: []
  type: TYPE_NORMAL
- en: which we recognize as an unnormalized beta distribution with parameters \(\alpha+k\)
    and \(\beta+n-k\).
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we observe `k` successes in `n` trials, we can do the update by making
    a beta distribution with parameters `alpha+k` and `beta+n-k`. That’s what this
    function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Again, the conjugate prior gives us insight into the meaning of the parameters;
    \(\alpha\) is related to the number of observed successes; \(\beta\) is related
    to the number of failures.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how we do the update with the observed data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To confirm that it works, I’ll evaluate the posterior distribution for the possible
    values of `xs` and put the results in a `Pmf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And we can compare the posterior distribution we just computed with the results
    from the grid algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell source Hide code cell source</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]</details> ![_images/6690cfacd465eb40d9ec441a2922b3fdf2f2f9656494ba5973edb6e05280cb97.png](../Images/abc447a9fedcb77f484b279731c683b2.png)'
  prefs: []
  type: TYPE_NORMAL
- en: They are the same other than small differences due to floating-point approximations.
  prefs: []
  type: TYPE_NORMAL
- en: The examples so far are problems we have already solved, so let’s try something
    new.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Lions and Tigers and Bears
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we visit a wild animal preserve where we know that the only animals
    are lions and tigers and bears, but we don’t know how many of each there are.
    During the tour, we see 3 lions, 2 tigers, and one bear. Assuming that every animal
    had an equal chance to appear in our sample, what is the probability that the
    next animal we see is a bear?
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, we’ll use the data to estimate the prevalence of each
    species, that is, what fraction of the animals belong to each species. If we know
    the prevalences, we can use the multinomial distribution to compute the probability
    of the data. For example, suppose we know that the fraction of lions, tigers,
    and bears is 0.4, 0.3, and 0.3, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case the probability of the data is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, we could choose a prior for the prevalences and do a Bayesian update using
    the multinomial distribution to compute the probability of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s an easier way, because the multinomial distribution has a conjugate
    prior: the Dirichlet distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: The Dirichlet Distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Dirichlet distribution is a multivariate distribution, like the multivariate
    normal distribution we used in <<_MultivariateNormalDistribution>> to describe
    the distribution of penguin measurements.
  prefs: []
  type: TYPE_NORMAL
- en: In that example, the quantities in the distribution are pairs of flipper length
    and culmen length, and the parameters of the distribution are a vector of means
    and a matrix of covariances.
  prefs: []
  type: TYPE_NORMAL
- en: In a Dirichlet distribution, the quantities are vectors of probabilities, \(\mathbf{x}\),
    and the parameter is a vector, \(\mathbf{\alpha}\).
  prefs: []
  type: TYPE_NORMAL
- en: An example will make that clearer. SciPy provides a `dirichlet` object that
    represents a Dirichlet distribution. Here’s an instance with \(\mathbf{\alpha}
    = 1, 2, 3\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we provided three parameters, the result is a distribution of three variables.
    If we draw a random value from this distribution, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: The result is an array of three values. They are bounded between 0 and 1, and
    they always add up to 1, so they can be interpreted as the probabilities of a
    set of outcomes that are mutually exclusive and collectively exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the distributions of these values look like. I’ll draw 1000
    random vectors from this distribution, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: The result is an array with 1000 rows and three columns. I’ll compute the `Cdf`
    of the values in each column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The result is a list of `Cdf` objects that represent the marginal distributions
    of the three variables. Here’s what they look like.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]</details> ![_images/38e3455314147946835c8800653dfd01a9f1c97c9b568a01c8e33c8802a29287.png](../Images/9936b94966fbbbda87abcfe0339c0257.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Column 0, which corresponds to the lowest parameter, contains the lowest probabilities.
    Column 2, which corresponds to the highest parameter, contains the highest probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, these marginal distributions are beta distributions. The following
    function takes a sequence of parameters, `alpha`, and computes the marginal distribution
    of variable `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can use it to compute the marginal distribution for the three variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The following plot shows the CDF of these distributions as gray lines and compares
    them to the CDFs of the samples.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]</details> ![_images/d2b045b7f54a65ceb60914590d7732e667f5f95b187400fa17363aed09dfab01.png](../Images/f50fbf1c81705f94c9ff9b1e33a4d90c.png)'
  prefs: []
  type: TYPE_NORMAL
- en: This confirms that the marginals of the Dirichlet distribution are beta distributions.
    And that’s useful because the Dirichlet distribution is the conjugate prior for
    the multinomial likelihood function.
  prefs: []
  type: TYPE_NORMAL
- en: If the prior distribution is Dirichlet with parameter vector `alpha` and the
    data is a vector of observations, `data`, the posterior distribution is Dirichlet
    with parameter vector `alpha + data`.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise at the end of this chapter, you can use this method to solve
    the Lions and Tigers and Bears problem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After reading this chapter, if you feel like you’ve been tricked, I understand.
    It turns out that many of the problems in this book can be solved with just a
    few arithmetic operations. So why did we go to all the trouble of using grid algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, there are only a few problems we can solve with conjugate priors; in
    fact, this chapter includes most of the ones that are useful in practice.
  prefs: []
  type: TYPE_NORMAL
- en: For the vast majority of problems, there is no conjugate prior and no shortcut
    to compute the posterior distribution. That’s why we need grid algorithms and
    the methods in the next two chapters, Approximate Bayesian Computation (ABC) and
    Markov chain Monte Carlo methods (MCMC).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Exercise:** In the second version of the World Cup problem, the data we use
    for the update is not the number of goals in a game, but the time until the first
    goal. So the probability of the data is given by the exponential distribution
    rather than the Poisson distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: But it turns out that the gamma distribution is *also* the conjugate prior of
    the exponential distribution, so there is a simple way to compute this update,
    too. The PDF of the exponential distribution is a function of \(t\) with \(\lambda\)
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: \[\lambda e^{-\lambda t}\]
  prefs: []
  type: TYPE_NORMAL
- en: Multiply the PDF of the gamma prior by this likelihood, confirm that the result
    is an unnormalized gamma distribution, and see if you can derive its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Write a few lines of code to update `prior_gamma` with the data from this version
    of the problem, which was a first goal after 11 minutes and a second goal after
    an additional 12 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to express these quantities in units of games, which are approximately
    90 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/4b02d1d83de1cd604d399109a433c3edb273cfc7a8407045a8aade575d235c6e.png](../Images/4d92153053608fe4987f356fc8345b6d.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** For problems like the Euro problem where the likelihood function
    is binomial, we can do a Bayesian update with just a few arithmetic operations,
    but only if the prior is a beta distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want a uniform prior, we can use a beta distribution with `alpha=1` and
    `beta=1`. But what can we do if the prior distribution we want is not a beta distribution?
    For example, in <<_TrianglePrior>> we also solved the Euro problem with a triangle
    prior, which is not a beta distribution.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we can often find a beta distribution that is a good-enough
    approximation for the prior we want. See if you can find a beta distribution that
    fits the triangle prior, then update it using `update_beta`.
  prefs: []
  type: TYPE_NORMAL
- en: Use `pmf_from_dist` to make a `Pmf` that approximates the posterior distribution
    and compare it to the posterior we just computed using a grid algorithm. How big
    is the largest difference between them?
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the triangle prior again.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: And here’s the update.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: To get you started, here’s the beta distribution that we used as a uniform prior.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: And here’s what it looks like compared to the triangle prior.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/8a092622087a81b63220299ed339ad33e748615fdf8b8c669f8a3a99a5c416f1.png](../Images/73af9d0e16a3a3a26f30c218b855c169.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Now you take it from there.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/c876c409c11dd54ba4da7d89608ab9129059f96d92b73aa846a81dcf77d3d82c.png](../Images/70a181595d707f471e4b328a30987f04.png)</details><details
    class="hide above-input"><summary aria-label="Toggle hidden content">Show code
    cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** [3Blue1Brown](https://en.wikipedia.org/wiki/3Blue1Brown) is a
    YouTube channel about math; if you are not already aware of it, I recommend it
    highly. In [this video](https://www.youtube.com/watch?v=8idr1WZ1A7Q) the narrator
    presents this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: You are buying a product online and you see three sellers offering the same
    product at the same price. One of them has a 100% positive rating, but with only
    10 reviews. Another has a 96% positive rating with 50 total reviews. And yet another
    has a 93% positive rating, but with 200 total reviews.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which one should you buy from?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s think about how to model this scenario. Suppose each seller has some unknown
    probability, `x`, of providing satisfactory service and getting a positive rating,
    and we want to choose the seller with the highest value of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only model for this scenario, and it is not necessarily the
    best. An alternative would be something like item response theory, where sellers
    have varying ability to provide satisfactory service and customers have varying
    difficulty of being satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: But the first model has the virtue of simplicity, so let’s see where it gets
    us.
  prefs: []
  type: TYPE_NORMAL
- en: As a prior, I suggest a beta distribution with `alpha=8` and `beta=2`. What
    does this prior look like and what does it imply about sellers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the data to update the prior for the three sellers and plot the posterior
    distributions. Which seller has the highest posterior mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How confident should we be about our choice? That is, what is the probability
    that the seller with the highest posterior mean actually has the highest value
    of `x`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider a beta prior with `alpha=0.7` and `beta=0.5`. What does this prior
    look like and what does it imply about sellers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the analysis again with this prior and see what effect it has on the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note: When you evaluate the beta distribution, you should restrict the range
    of `xs` so it does not include 0 and 1\. When the parameters of the beta distribution
    are less than 1, the probability density goes to infinity at 0 and 1\. From a
    mathematical point of view, that’s not a problem; it is still a proper probability
    distribution. But from a computational point of view, it means we have to avoid
    evaluating the PDF at 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/10f1e732645ad625d44851743d4fe343a94841acc5b05777fdb17545b3e088be.png](../Images/3467044fe4b8f6bbd9e4caaca9246e97.png)</details><details
    class="hide above-input"><summary aria-label="Toggle hidden content">Show code
    cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/287d7bc9e8018421486a23dfd8721014d0c702fff0d03d83edec1951ee90458a.png](../Images/b9e1eb89662d72d4365e5ef48b669c68.png)</details><details
    class="hide above-input"><summary aria-label="Toggle hidden content">Show code
    cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '|  | probs |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0.2948 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.4750 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.2302 |</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Use a Dirichlet prior with parameter vector `alpha = [1, 1, 1]`
    to solve the Lions and Tigers and Bears problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we visit a wild animal preserve where we know that the only animals
    are lions and tigers and bears, but we don’t know how many of each there are.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: During the tour, we see three lions, two tigers, and one bear. Assuming that
    every animal had an equal chance to appear in our sample, estimate the prevalence
    of each species.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the probability that the next animal we see is a bear?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '|  | prob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| lion | 0.444444 |'
  prefs: []
  type: TYPE_TB
- en: '| tiger | 0.333333 |'
  prefs: []
  type: TYPE_TB
- en: '| bear | 0.222222 |</details>'
  prefs: []
  type: TYPE_NORMAL
