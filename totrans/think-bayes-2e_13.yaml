- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkBayes2/chap10.html](https://allendowney.github.io/ThinkBayes2/chap10.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In <<_TheEuroProblem>> I presented a problem from David MacKay’s book, [*Information
    Theory, Inference, and Learning Algorithms*](http://www.inference.org.uk/mackay/itila/p0.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '“A statistical statement appeared in *The Guardian* on Friday January 4, 2002:'
  prefs: []
  type: TYPE_NORMAL
- en: When spun on edge 250 times, a Belgian one-euro coin came up heads 140 times
    and tails 110\. `It looks very suspicious to me,’ said Barry Blight, a statistics
    lecturer at the London School of Economics. `If the coin were unbiased, the chance
    of getting a result as extreme as that would be less than 7%.’
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “But [MacKay asks] do these data give evidence that the coin is biased rather
    than fair?”
  prefs: []
  type: TYPE_NORMAL
- en: 'We started to answer this question in <<_EstimatingProportions>>; to review,
    our answer was based on these modeling decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: If you spin a coin on edge, there is some probability, \(x\), that it will land
    heads up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of \(x\) varies from one coin to the next, depending on how the coin
    is balanced and possibly other factors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with a uniform prior distribution for \(x\), we updated it with the
    given data, 140 heads and 110 tails. Then we used the posterior distribution to
    compute the most likely value of \(x\), the posterior mean, and a credible interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we never really answered MacKay’s question: “Do these data give evidence
    that the coin is biased rather than fair?”'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, finally, we will.
  prefs: []
  type: TYPE_NORMAL
- en: Estimation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s review the solution to the Euro problem from <<_TheBinomialLikelihoodFunction>>.
    We started with a uniform prior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And we used the binomial distribution to compute the probability of the data
    for each possible value of \(x\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We computed the posterior distribution in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And here’s what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]</details> ![_images/d2164f5205e6d919479cdbbc6ada601ed81c32de4774fca532169fb4e140d36b.png](../Images/cff6b0a6ffb873c1f1ca6afedfa221b3.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the posterior mean is about 0.56, with a 90% credible interval from 0.51
    to 0.61.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The prior mean was 0.5, and the posterior mean is 0.56, so it seems like the
    data is evidence that the coin is biased.
  prefs: []
  type: TYPE_NORMAL
- en: But, it turns out not to be that simple.
  prefs: []
  type: TYPE_NORMAL
- en: Evidence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In <<_OliversBlood>>, I said that data are considered evidence in favor of a
    hypothesis, \(A\), if the data are more likely under \(A\) than under the alternative,
    \(B\); that is if
  prefs: []
  type: TYPE_NORMAL
- en: \[P(D|A) > P(D|B)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we can quantify the strength of the evidence by computing the
    ratio of these likelihoods, which is known as the [Bayes factor](https://en.wikipedia.org/wiki/Bayes_factor)
    and often denoted \(K\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[K = \frac{P(D|A)}{P(D|B)}\]
  prefs: []
  type: TYPE_NORMAL
- en: So, for the Euro problem, let’s consider two hypotheses, `fair` and `biased`,
    and compute the likelihood of the data under each hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the coin is fair, the probability of heads is 50%, and we can compute the
    probability of the data (140 heads out of 250 spins) using the binomial distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That’s the probability of the data, given that the coin is fair.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if the coin is biased, what’s the probability of the data? That depends
    on what “biased” means. If we know ahead of time that “biased” means the probability
    of heads is 56%, we can use the binomial distribution again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can compute the likelihood ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The data are about 6 times more likely if the coin is biased, by this definition,
    than if it is fair.
  prefs: []
  type: TYPE_NORMAL
- en: But we used the data to define the hypothesis, which seems like cheating. To
    be fair, we should define “biased” before we see the data.
  prefs: []
  type: TYPE_NORMAL
- en: Uniformly Distributed Bias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose “biased” means that the probability of heads is anything except 50%,
    and all other values are equally likely.
  prefs: []
  type: TYPE_NORMAL
- en: We can represent that definition by making a uniform distribution and removing
    50%.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To compute the total probability of the data under this hypothesis, we compute
    the conditional probability of the data for each value of \(x\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then multiply by the prior probabilities and add up the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So that’s the probability of the data under the “biased uniform” hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can compute the likelihood ratio of the data under the `fair` and `biased
    uniform` hypotheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The data are about two times more likely if the coin is fair than if it is biased,
    by this definition of “biased”.
  prefs: []
  type: TYPE_NORMAL
- en: To get a sense of how strong that evidence is, we can apply Bayes’s rule. For
    example, if the prior probability is 50% that the coin is biased, the prior odds
    are 1, so the posterior odds are about 2.1 to 1 and the posterior probability
    is about 68%.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Evidence that “moves the needle” from 50% to 68% is not very strong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose “biased” doesn’t mean every value of \(x\) is equally likely. Maybe
    values near 50% are more likely and values near the extremes are less likely.
    We could use a triangle-shaped distribution to represent this alternative definition
    of “biased”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we did with the uniform distribution, we can remove 50% as a possible value
    of \(x\) (but it doesn’t make much difference if we skip this detail).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what the triangle prior looks like, compared to the uniform prior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/6830561f7133fda6957c4ae75d18bdd7f080e7e4e9ea0816073ac15253a8bbd8.png](../Images/323e88d01bc75218ed781a3bb0e371b0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Exercise:** Now compute the total probability of the data under this definition
    of “biased” and compute the Bayes factor, compared with the fair hypothesis. Is
    the data evidence that the coin is biased?'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Bayesian Hypothesis Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we’ve done so far in this chapter is sometimes called “Bayesian hypothesis
    testing” in contrast with [statistical hypothesis testing](https://en.wikipedia.org/wiki/Statistical_hypothesis_testing).
  prefs: []
  type: TYPE_NORMAL
- en: In statistical hypothesis testing, we compute a p-value, which is hard to define
    concisely, and use it to determine whether the results are “statistically significant”,
    which is also hard to define concisely.
  prefs: []
  type: TYPE_NORMAL
- en: The Bayesian alternative is to report the Bayes factor, \(K\), which summarizes
    the strength of the evidence in favor of one hypothesis or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Some people think it is better to report \(K\) than a posterior probability
    because \(K\) does not depend on a prior probability. But as we saw in this example,
    \(K\) often depends on a precise definition of the hypotheses, which can be just
    as controversial as a prior probability.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, Bayesian hypothesis testing is better because it measures the
    strength of the evidence on a continuum, rather that trying to make a binary determination.
    But it doesn’t solve what I think is the fundamental problem, which is that hypothesis
    testing is not asking the question we really care about.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see why, suppose you test the coin and decide that it is biased after all.
    What can you do with this answer? In my opinion, not much. In contrast, there
    are two questions I think are more useful (and therefore more meaningful):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prediction: Based on what we know about the coin, what should we expect to
    happen in the future?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decision-making: Can we use those predictions to make better decisions?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we’ve seen a few examples of prediction. For example, in <<_PoissonProcesses>>
    we used the posterior distribution of goal-scoring rates to predict the outcome
    of soccer games.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we’ve seen one previous example of decision analysis: In <<_DecisionAnalysis>>
    we used the distribution of prices to choose an optimal bid on *The Price is Right*.'
  prefs: []
  type: TYPE_NORMAL
- en: So let’s finish this chapter with another example of Bayesian decision analysis,
    the Bayesian Bandit strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Bayesian Bandits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever been to a casino, you have probably seen a slot machine, which
    is sometimes called a “one-armed bandit” because it has a handle like an arm and
    the ability to take money like a bandit.
  prefs: []
  type: TYPE_NORMAL
- en: The Bayesian Bandit strategy is named after one-armed bandits because it solves
    a problem based on a simplified version of a slot machine.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that each time you play a slot machine, there is a fixed probability
    that you win. And suppose that different machines give you different probabilities
    of winning, but you don’t know what the probabilities are.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, you have the same prior belief about each of the machines, so you
    have no reason to prefer one over the others. But if you play each machine a few
    times, you can use the results to estimate the probabilities. And you can use
    the estimated probabilities to decide which machine to play next.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, that’s the Bayesian bandit strategy. Now let’s see the details.
  prefs: []
  type: TYPE_NORMAL
- en: Prior Beliefs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we know nothing about the probability of winning, we can start with a uniform
    prior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Supposing we are choosing from four slot machines, I’ll make four copies of
    the prior, one for each machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function displays four distributions in a grid.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what the prior distributions look like for the four machines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/43ebe13555409fdcc3d9acef81fa8485ba3f0a8f7490aa37ea915670b64820f1.png](../Images/925b50e2cc67d57c25d7f88b6cd1cb96.png)'
  prefs: []
  type: TYPE_IMG
- en: The Update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time we play a machine, we can use the outcome to update our beliefs. The
    following function does the update.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This function updates the prior distribution in place. `pmf` is a `Pmf` that
    represents the prior distribution of `x`, which is the probability of winning.
  prefs: []
  type: TYPE_NORMAL
- en: '`data` is a string, either `W` if the outcome is a win or `L` if the outcome
    is a loss.'
  prefs: []
  type: TYPE_NORMAL
- en: The likelihood of the data is either `xs` or `1-xs`, depending on the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we choose a machine, play 10 times, and win once. We can compute the
    posterior distribution of `x`, based on this outcome, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what the posterior looks like.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]</details> ![_images/cf5bcaaeed0a5e04ea726bd4023cf9330e5eebd0aef3ccd5681283ffc4d340ad.png](../Images/ba74321490b0e13ca4e86ff4d790ef8b.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Bandits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now suppose we have four machines with these probabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Remember that as a player, we don’t know these probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The following function takes the index of a machine, simulates playing the machine
    once, and returns the outcome, `W` or `L`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`counter` is a `Counter`, which is a kind of dictionary we’ll use to keep track
    of how many times each machine is played.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a test that plays each machine 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Each time through the inner loop, we play one machine and update our beliefs.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what our posterior beliefs look like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/c371b33d36f081b1acdcca982a0ad66e8ba54ad96f3502be77eadef8aff83ee7.png](../Images/f3c7983b850e6c56a22d66053871b310.png)'
  prefs: []
  type: TYPE_IMG
- en: Here are the actual probabilities, posterior means, and 90% credible intervals.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell source Hide code cell source</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Actual P(win) | Posterior mean | Credible interval |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0.1 | 0.250 | [0.08, 0.47] |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.2 | 0.250 | [0.08, 0.47] |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.3 | 0.500 | [0.27, 0.73] |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0.4 | 0.417 | [0.2, 0.65] |'
  prefs: []
  type: TYPE_TB
- en: We expect the credible intervals to contain the actual probabilities most of
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: Explore and Exploit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on these posterior distributions, which machine do you think we should
    play next? One option would be to choose the machine with the highest posterior
    mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'That would not be a bad idea, but it has a drawback: since we have only played
    each machine a few times, the posterior distributions are wide and overlapping,
    which means we are not sure which machine is the best; if we focus on one machine
    too soon, we might choose the wrong machine and play it more than we should.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid that problem, we could go to the other extreme and play all machines
    equally until we are confident we have identified the best machine, and then play
    it exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s not a bad idea either, but it has a drawback: while we are gathering
    data, we are not making good use of it; until we’re sure which machine is the
    best, we are playing the others more than we should.'
  prefs: []
  type: TYPE_NORMAL
- en: The Bayesian Bandits strategy avoids both drawbacks by gathering and using data
    at the same time. In other words, it balances exploration and exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel of the idea is called [Thompson sampling](https://en.wikipedia.org/wiki/Thompson_sampling):
    when we choose a machine, we choose at random so that the probability of choosing
    each machine is proportional to the probability that it is the best.'
  prefs: []
  type: TYPE_NORMAL
- en: Given the posterior distributions, we can compute the “probability of superiority”
    for each machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one way to do it. We can draw a sample of 1000 values from each posterior
    distribution, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The result has 4 rows and 1000 columns. We can use `argmax` to find the index
    of the largest value in each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `Pmf` of these indices is the fraction of times each machine yielded the
    highest values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '|  | probs |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0.048 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.043 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.625 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0.284 |'
  prefs: []
  type: TYPE_TB
- en: These fractions approximate the probability of superiority for each machine.
    So we could choose the next machine by choosing a value from this `Pmf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: But that’s a lot of work to choose a single value, and it’s not really necessary,
    because there’s a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: If we draw a single random value from each posterior distribution and select
    the machine that yields the highest value, it turns out that we’ll select each
    machine in proportion to its probability of superiority.
  prefs: []
  type: TYPE_NORMAL
- en: That’s what the following function does.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This function chooses one value from the posterior distribution of each machine
    and then uses `argmax` to find the index of the machine that yielded the highest
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Putting it all together, the following function chooses a machine, plays once,
    and updates `beliefs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To test it out, let’s start again with a fresh set of beliefs and an empty `Counter`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the bandit algorithm 100 times, we can see how `beliefs` gets updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/020ff49d90aa605dcced01aefa1c2cfa99d6e29e2be17d4a4d8fa486bcb918b3.png](../Images/3dcd9ae63fc1320012c3f0ddfd24960d.png)'
  prefs: []
  type: TYPE_IMG
- en: The following table summarizes the results.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Actual P(win) | Posterior mean | Credible interval |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0.1 | 0.107 | [0.0, 0.31] |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.2 | 0.269 | [0.14, 0.42] |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.3 | 0.293 | [0.18, 0.41] |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0.4 | 0.438 | [0.3, 0.58] |'
  prefs: []
  type: TYPE_TB
- en: 'The credible intervals usually contain the actual probabilities of winning.
    The estimates are still rough, especially for the lower-probability machines.
    But that’s a feature, not a bug: the goal is to play the high-probability machines
    most often. Making the estimates more precise is a means to that end, but not
    an end itself.'
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, let’s see how many times each machine got played.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell source Hide code cell source</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Actual P(win) | Times played |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0.1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.2 | 24 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.3 | 39 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0.4 | 30 |'
  prefs: []
  type: TYPE_TB
- en: If things go according to plan, the machines with higher probabilities should
    get played more often.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we finally solved the Euro problem, determining whether the
    data support the hypothesis that the coin is fair or biased. We found that the
    answer depends on how we define “biased”. And we summarized the results using
    a Bayes factor, which quantifies the strength of the evidence.
  prefs: []
  type: TYPE_NORMAL
- en: But the answer wasn’t satisfying because, in my opinion, the question wasn’t
    interesting. Knowing whether the coin is biased is not useful unless it helps
    us make better predictions and better decisions.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of a more interesting question, we looked at the “one-armed bandit”
    problem and a strategy for solving it, the Bayesian bandit algorithm, which tries
    to balance exploration and exploitation, that is, gathering more information and
    making the best use of the information we have.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you’ll have a chance to explore adaptive strategies for standardized
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Bayesian bandits and adaptive testing are examples of [Bayesian decision theory](https://wiki.lesswrong.com/wiki/Bayesian_decision_theory),
    which is the idea of using a posterior distribution as part of a decision-making
    process, often by choosing an action that minimizes the costs we expect on average
    (or maximizes a benefit).
  prefs: []
  type: TYPE_NORMAL
- en: The strategy we used in <<_MaximizingExpectedGain>> to bid on *The Price is
    Right* is another example.
  prefs: []
  type: TYPE_NORMAL
- en: These strategies demonstrate what I think is the biggest advantage of Bayesian
    methods over classical statistics. When we represent knowledge in the form of
    probability distributions, Bayes’s theorem tells us how to change our beliefs
    as we get more data, and Bayesian decision theory tells us how to make that knowledge
    actionable.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Exercise:** Standardized tests like the [SAT](https://en.wikipedia.org/wiki/SAT)
    are often used as part of the admission process at colleges and universities.
    The goal of the SAT is to measure the academic preparation of the test-takers;
    if it is accurate, their scores should reflect their actual ability in the domain
    of the test.'
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, tests like the SAT were taken with paper and pencil, but now
    students have the option of taking the test online. In the online format, it is
    possible for the test to be “adaptive”, which means that it can [choose each question
    based on responses to previous questions](https://www.nytimes.com/2018/04/05/education/learning/tests-act-sat.html).
  prefs: []
  type: TYPE_NORMAL
- en: If a student gets the first few questions right, the test can challenge them
    with harder questions. If they are struggling, it can give them easier questions.
    Adaptive testing has the potential to be more “efficient”, meaning that with the
    same number of questions an adaptive test could measure the ability of a tester
    more precisely.
  prefs: []
  type: TYPE_NORMAL
- en: To see whether this is true, we will develop a model of an adaptive test and
    quantify the precision of its measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Details of this exercise are in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: I chose `a` to make the range of scores comparable to the SAT, which reports
    scores from 200 to 800.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what the logistic curve looks like for a question with difficulty 500
    and a range of abilities.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/4056a18b35ba87b9cbfdf040678438925cbb5840b7dedc0ce76f95a6eb6b150b.png](../Images/3d44a6c66ae13372de3e4cdb9efda095.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Someone with `ability=900` is nearly certain to get the right answer. Someone
    with `ability=100` has about a 25% change of getting the right answer by guessing.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating the Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate the test, we’ll use the same structure we used for the bandit strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: A function called `play` that simulates a test-taker answering one question.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function called `choose` that chooses the next question to pose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function called `update` that uses the outcome (a correct response or not)
    to update the estimate of the test-taker’s ability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s `play`, which takes `ability` and `difficulty` as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '`play` uses `prob_correct` to compute the probability of a correct answer and
    `np.random.random` to generate a random value between 0 and 1\. The return value
    is `True` for a correct response and `False` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: As a test, let’s simulate a test-taker with `ability=600` answering a question
    with `difficulty=500`. The probability of a correct response is about 80%.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose this person takes a test with 51 questions, all with the same difficulty,
    `500`. We expect them to get about 80% of the questions correct.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the result of one simulation.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: We expect them to get about 80% of the questions right.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s suppose we don’t know the test-taker’s ability. We can use the data
    we just generated to estimate it. And that’s what we’ll do next.
  prefs: []
  type: TYPE_NORMAL
- en: The Prior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SAT is designed so the distribution of scores is roughly normal, with mean
    500 and standard deviation 100. So the lowest score, 200, is three standard deviations
    below the mean, and the highest score, 800, is three standard deviations above.
  prefs: []
  type: TYPE_NORMAL
- en: We could use that distribution as a prior, but it would tend to cut off the
    low and high ends of the distribution. Instead, I’ll inflate the standard deviation
    to 300, to leave open the possibility that `ability` can be less than 200 or more
    than 800.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a `Pmf` that represents the prior distribution.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: And here’s what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/f6ff46cbaef200d7e887b81758d28ab084b928962a3b5f9a698c824c1e36dd72.png](../Images/6b094033244393276b1d1a97d6adb274.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: The Update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following function takes a prior `Pmf` and the outcome of a single question,
    and updates the `Pmf` in place.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` is a tuple that contains the difficulty of a question and the outcome:
    `True` if the response was correct and `False` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: As a test, let’s do an update based on the outcomes we simulated previously,
    based on a person with `ability=600` answering 51 questions with `difficulty=500`.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what the posterior distribution looks like.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/553368a9dc3a4c555472e4f17489bf9253f43d3f3ee2101c3b304bcba13e6c6f.png](../Images/63249dd4cc939a3f7d16ff724b2f40f2.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: The posterior mean is pretty close to the test-taker’s actual ability, which
    is 600.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: If we run this simulation again, we’ll get different results.
  prefs: []
  type: TYPE_NORMAL
- en: Adaptation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s simulate an adaptive test. I’ll use the following function to choose
    questions, starting with the simplest strategy: all questions have the same difficulty.'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: As parameters, `choose` takes `i`, which is the index of the question, and `belief`,
    which is a `Pmf` representing the posterior distribution of `ability`, based on
    responses to previous questions.
  prefs: []
  type: TYPE_NORMAL
- en: This version of `choose` doesn’t use these parameters; they are there so we
    can test other strategies (see the exercises at the end of the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The following function simulates a person taking a test, given that we know
    their actual ability.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: The return values are a `Pmf` representing the posterior distribution of ability
    and a `DataFrame` containing the difficulty of the questions and the outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example, again for a test-taker with `ability=600`.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the trace to see how many responses were correct.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: And here’s what the posterior looks like.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/6fecd64a2fbf0f61eb5419cb676798c9831a102903ea96ca668ee184f4da95f6.png](../Images/06dc60e1e59865d48a2f8ee79cd5816c.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the posterior distribution represents a pretty good estimate of the test-taker’s
    actual ability.
  prefs: []
  type: TYPE_NORMAL
- en: Quantifying Precision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To quantify the precision of the estimates, I’ll use the standard deviation
    of the posterior distribution. The standard deviation measures the spread of the
    distribution, so higher value indicates more uncertainty about the ability of
    the test-taker.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the standard deviation of the posterior distribution
    is about 40.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: For an exam where all questions have the same difficulty, the precision of the
    estimate depends strongly on the ability of the test-taker. To show that, I’ll
    loop through a range of abilities and simulate a test using the version of `choice`
    that always returns `difficulty=500`.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: The following plot shows the standard deviation of the posterior distribution
    for one simulation at each level of ability.
  prefs: []
  type: TYPE_NORMAL
- en: The results are noisy, so I also plot a curve fitted to the data by [local regression](https://en.wikipedia.org/wiki/Local_regression).
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/49fcae9333f76f35c854dcd4b654625f8dd41b8415ea903a5c3434780d2ea9fb.png](../Images/d29aa0df7d3b18ac9daca492b6efe4b9.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: The test is most precise for people with ability between `500` and `600`, less
    precise for people at the high end of the range, and even worse for people at
    the low end.
  prefs: []
  type: TYPE_NORMAL
- en: When all the questions have difficulty `500`, a person with `ability=800` has
    a high probability of getting them right. So when they do, we don’t learn very
    much about them.
  prefs: []
  type: TYPE_NORMAL
- en: If the test includes questions with a range of difficulty, it provides more
    information about people at the high and low ends of the range.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise at the end of the chapter, you’ll have a chance to try out other
    strategies, including adaptive strategies that choose each question based on previous
    outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminatory Power
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section we used the standard deviation of the posterior distribution
    to quantify the precision of the estimates. Another way to describe the performance
    of the test (as opposed to the performance of the test-takers) is to measure “discriminatory
    power”, which is the ability of the test to distinguish correctly between test-takers
    with different ability.
  prefs: []
  type: TYPE_NORMAL
- en: To measure discriminatory power, I’ll simulate a person taking the test 100
    times; after each simulation, I’ll use the mean of the posterior distribution
    as their “score”.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Here are samples of scores for people with several levels of ability.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what the distributions of scores look like.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/e2f80922b8b9560c88074262e5b71df8c9b98feb9d33b222084ab78f75b14f93.png](../Images/0a2712bec0950fe312afd311635edd84.png)</details>'
  prefs: []
  type: TYPE_NORMAL
- en: On average, people with higher ability get higher scores, but anyone can have
    a bad day, or a good day, so there is some overlap between the distributions.
  prefs: []
  type: TYPE_NORMAL
- en: For people with ability between `500` and `600`, where the precision of the
    test is highest, the discriminatory power of the test is also high.
  prefs: []
  type: TYPE_NORMAL
- en: If people with abilities `500` and `600` take the test, it is almost certain
    that the person with higher ability will get a higher score.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Between people with abilities `600` and `700`, it is less certain.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: And between people with abilities `700` and `800`, it is not certain at all.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: But remember that these results are based on a test where all questions are
    equally difficult. If you do the exercises at the end of the chapter, you’ll see
    that the performance of the test is better if it includes questions with a range
    of difficulties, and even better if the test it is adaptive.
  prefs: []
  type: TYPE_NORMAL
- en: Go back and modify `choose`, which is the function that chooses the difficulty
    of the next question.
  prefs: []
  type: TYPE_NORMAL
- en: Write a version of `choose` that returns a range of difficulties by using `i`
    as an index into a sequence of difficulties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a version of `choose` that is adaptive, so it choose the difficulty of
    the next question based `belief`, which is the posterior distribution of the test-taker’s
    ability, based on the outcome of previous responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For both new versions, run the simulations again to quantify the precision of
    the test and its discriminatory power.
  prefs: []
  type: TYPE_NORMAL
- en: For the first version of `choose`, what is the ideal distribution of difficulties?
  prefs: []
  type: TYPE_NORMAL
- en: For the second version, what is the adaptive strategy that maximizes the precision
    of the test over the range of abilities?
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell content Hide code cell content</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]</details> <details class="hide above-input"><summary aria-label="Toggle
    hidden content">Show code cell content Hide code cell content</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]</details>'
  prefs: []
  type: TYPE_NORMAL
