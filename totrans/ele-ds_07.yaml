- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ElementsOfDataScience/05_dictionaries.html](https://allendowney.github.io/ElementsOfDataScience/05_dictionaries.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Click here to run this notebook on Colab](https://colab.research.google.com/github/AllenDowney/ElementsOfDataScience/blob/master/05_dictionaries.ipynb)
    or [click here to download it](https://github.com/AllenDowney/ElementsOfDataScience/raw/master/05_dictionaries.ipynb).'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter we used a `for` loop to read a file and count the words.
    In this chapter, you’ll learn about a new type called a **dictionary**, and we’ll
    use it to count the number of unique words and the number of times each one appears.
  prefs: []
  type: TYPE_NORMAL
- en: You will also see how to select an element from a sequence (tuple, list, or
    array). And you will learn a little about Unicode, which is used to represent
    letters, numbers, and punctuation for almost every language in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you have a variable named `t` that refers to a list or tuple. You can
    select an element using the **bracket operator**, `[]`. For example, here’s a
    tuple of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the first element, we put `0` in brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the second element, we put `1` in brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the third element, we put `2` in brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The number in brackets is called an **index** because it indicates which element
    we want. Tuples and lists use zero-based numbering; that is, the index of the
    first element is 0\. Some other programming languages use one-based numbering.
    There are pros and cons of both systems (see [https://en.wikipedia.org/wiki/Zero-based_numbering](https://en.wikipedia.org/wiki/Zero-based_numbering)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The index in brackets can also be a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or an expression with variables, values, and operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But if the index goes past the end of the list or tuple, you get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the index has to be an integer; if it is any other type, you get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** You can use negative integers as indices. Try using `-1` and
    `-2` as indices, and see if you can figure out what they do.'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A dictionary is similar to a tuple or list, but in a dictionary, the index
    can be almost any type, not just an integer. We can create an empty dictionary
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can add elements like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the indices are the strings, `'one'` and `'two'` If you display
    the dictionary, it shows each index and the corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of creating an empty dictionary and then adding elements, you can create
    a dictionary and specify the elements at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we are talking about dictionaries, an index is usually called a **key**.
    In this example, the keys are strings and the corresponding values are integers.
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary is also called a **map**, because it represents correspondence
    or “mapping”, between keys and values. So we might say that this dictionary maps
    from English number names to the corresponding integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the bracket operator to select an element from a dictionary, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But don’t forget the quotation marks. Without them, Python looks for a variable
    named `two` and doesn’t find one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether a particular key is in a dictionary, you can use the special
    word `in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Because the word `in` is an operator in Python, you can’t use it as a variable
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a key is already in a dictionary, adding it again has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can change the value associated with a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can loop through the keys in a dictionary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the keys and the values, one way to get them is to loop through
    the keys and look up the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can loop through both at the same time, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `items` method loops through the key-value pairs in the dictionary; each
    time through the loop, they are assigned to `key` and `value`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Make a dictionary with the integers `1`, `2`, and `3` as keys
    and strings as values. The strings should be the words “one”, “two”, and “three”
    or their equivalents in any language you know.'
  prefs: []
  type: TYPE_NORMAL
- en: Write a loop that prints just the values from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Counting Unique Words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter we downloaded *War and Peace* from Project Gutenberg
    and counted the number of lines and words. Now that we have dictionaries, we can
    also count the number of unique words and the number of times each one appears.
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the previous chapter, we can read the text of *War and Peace* and
    count the number of words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To count the number of unique words, we’ll loop through the words in each line
    and add them as keys in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is the first example we’ve seen with one loop **nested** inside another.
  prefs: []
  type: TYPE_NORMAL
- en: The outer loop runs through the lines in the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inner loops runs through the words in each line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time through the inner loop, we add a word as a key in the dictionary,
    with the value 1\. If the same word appears more than once, it gets added to the
    dictionary again, which has no effect. So the dictionary contains only one copy
    of each unique word in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the loop, we can display the first 10 keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The dictionary contains all the words in the file, in order of first appearance.
    But each word only appears once, so the number of keys is the number of unique
    words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It looks like there are about 42,000 different words in the book, which is substantially
    less than the total number of words, about 560,000. But that’s not quite right,
    because we have not taken into account capitalization and punctuation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Before we deal with that problem, let’s practice with nested
    loops, that is, one loop inside another. Suppose you have a list of words, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Write a nested loop that iterates through each word in the list, and each letter
    in each word, and prints the letters on separate lines.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Capitalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we count unique words, we probably want to treat `The` and `the` as the
    same word. We can do that by converting all words to lower case, using the `lower`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`lower` creates a new string; it does not modify the original string.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can assign the new string back to the existing variable, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we can display the new value of `word`, we get the lowercase version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise:** Modify the previous loop so it makes a lowercase version of each
    word before adding it to the dictionary. How many unique words are there, if we
    ignore the difference between uppercase and lowercase?'
  prefs: []
  type: TYPE_NORMAL
- en: Removing Punctuation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove punctuation from the words, we can use `strip`, which removes specified
    characters from the beginning and end of a string. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `strip` removes all instances of `a` and `b` from the beginning
    and end of the word, but not from the middle. But note that it makes a new word;
    it doesn’t modify the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To remove punctuation, we can use the `string` library, which provides a variable
    named `punctuation`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`string.punctuation` contains the most common punctuation marks, but as we’ll
    see, not all of them. Nevertheless, we can use it to handle most cases. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`strip` removes the period at the end of `wrong`, but not the apostrophes in
    `It''s`, `don''t` and `what''s`. So that’s good, but we have one more problem
    to solve. Here’s another line from the book.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what happens when we try to remove the punctuation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It removes the comma after `anyone`, but not the period and quotation mark after
    `them`. The problem is that this kind of quotation mark is not in `string.punctuation`.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this problem, we’ll use the following loop, which
  prefs: []
  type: TYPE_NORMAL
- en: Reads the file and builds a dictionary that contains all punctuation marks that
    appear in the book, then
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses the `join` function to concatenate the keys of the dictionary in a single
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don’t have to understand everything about how it works, but you should read
    it and see how much you can figure out. You can read the documentation of the
    `unicodedata` library here at [https://docs.python.org/3/library/unicodedata.html](https://docs.python.org/3/library/unicodedata.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The result is a string containing all of the punctuation characters that appear
    in the document, in the order they first appear.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Modify the word-counting loop from the previous section to convert
    words to lower case *and* strip punctuation before adding them to the dictionary.
    Now how many unique words are there?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional: You might want to skip over the front matter and start with the text
    of Chapter 1, and skip over the license at the end, as we did in the previous
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Counting Word Frequencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section we counted the number of unique words, but we might
    also want to know how often each word appears. Then we can find the most common
    and least common words in the book. To count the frequency of each word, we’ll
    make a dictionary that maps from each word to the number of times it appears.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example that loops through a string and counts the number of times
    each letter appears.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement here uses a feature we have not seen before, an `else` clause.
    Here’s how it works.
  prefs: []
  type: TYPE_NORMAL
- en: First, it checks whether the letter, `x`, is already a key in the dictionary,
    `letter_counts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, it runs the first statement, `letter_counts[x] += 1`, which increments
    the value associated with the letter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, it runs the second statement, `letter_counts[x] = 1`, which adds
    `x` as a new key, with the value `1` indicating that we have seen the new letter
    once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is a dictionary that maps from each letter to the number of times
    it appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the most common letters, we can use a `Counter`, which is similar to
    a dictionary. To use it, we have to import a library called `collections`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use `collections.Counter` to convert the dictionary to a `Counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '`Counter` provides a function called `most_common` we can use to get the most
    common characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The result is a list of tuples, where each tuple contains a character and an
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Modify the loop from the previous exercise to count the frequency
    of the words in *War and Peace*; then print the 20 most common words and the number
    of times each one appears.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** You can run `most_common` with no value in parentheses, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a list of tuples, with one tuple for every unique word in the
    book. Assign the result to a variable so it doesn’t get displayed. Then answer
    the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How many times does the #1 ranked word appear (that is, the first element of
    the list)?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How many times does the #10 ranked word appear?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How many times does the #100 ranked word appear?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How many times does the #1000 ranked word appear?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How many times does the #10000 ranked word appear?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you see a pattern in the results? We will explore this pattern more in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Write a loop that counts how many words appear 200 times. What
    are they? How many words appear 100 times, 50 times, and 20 times?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional:** If you know how to define a function, write a function that takes
    a `Counter` and a frequency as arguments, prints all words with that frequency,
    and returns the number of words with that frequency.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduces dictionaries, which represent a collection of keys and
    values. We used a dictionary to count the number of unique words in a file and
    the number of times each one appears.
  prefs: []
  type: TYPE_NORMAL
- en: It also introduces the bracket operator, which selects an element from a list
    or tuple, or looks up a key in a dictionary and finds the corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: We saw some new methods for working with strings, including `lower` and `strip`.
    Finally, we used the `unicodedata` library to identify characters that are considered
    punctuation.
  prefs: []
  type: TYPE_NORMAL
