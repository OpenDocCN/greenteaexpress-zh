["```py\nfrom scipy.stats import gamma\n\nalpha = 1.4\ndist = gamma(alpha) \n```", "```py\nimport numpy as np\nfrom utils import pmf_from_dist\n\nlams = np.linspace(0, 10, 101)\nprior = pmf_from_dist(dist, lams) \n```", "```py\nfrom scipy.stats import poisson\n\nk = 4\nlikelihood = poisson(lams).pmf(k) \n```", "```py\nposterior = prior * likelihood\nposterior.normalize() \n```", "```py\n0.05015532557804499 \n```", "```py\ndef make_gamma_dist(alpha, beta):\n  \"\"\"Makes a gamma object.\"\"\"\n    dist = gamma(alpha, scale=1/beta)\n    dist.alpha = alpha\n    dist.beta = beta\n    return dist \n```", "```py\nalpha = 1.4\nbeta = 1\n\nprior_gamma = make_gamma_dist(alpha, beta)\nprior_gamma.mean() \n```", "```py\n1.4 \n```", "```py\ndef update_gamma(prior, data):\n  \"\"\"Update a gamma prior.\"\"\"\n    k, t = data\n    alpha = prior.alpha + k\n    beta = prior.beta + t\n    return make_gamma_dist(alpha, beta) \n```", "```py\ndata = 4, 1\nposterior_gamma = update_gamma(prior_gamma, data) \n```", "```py\nposterior_conjugate = pmf_from_dist(posterior_gamma, lams) \n```", "```py\nfrom utils import decorate\n\ndef decorate_rate(title=''):\n    decorate(xlabel='Goal scoring rate (lam)',\n             ylabel='PMF',\n             title=title) \n```", "```py\nposterior.plot(label='grid posterior', color='C1')\nposterior_conjugate.plot(label='conjugate posterior', \n                         color='C4', ls=':')\n\ndecorate_rate('Posterior distribution') \n```", "```py\nnp.allclose(posterior, posterior_conjugate) \n```", "```py\nTrue \n```", "```py\nfrom utils import make_uniform\n\nxs = np.linspace(0, 1, 101)\nuniform = make_uniform(xs, 'uniform') \n```", "```py\nfrom scipy.stats import binom\n\nk, n = 140, 250\nxs = uniform.qs\nlikelihood = binom.pmf(k, n, xs) \n```", "```py\nposterior = uniform * likelihood\nposterior.normalize() \n```", "```py\n0.003944617569326651 \n```", "```py\nimport scipy.stats\n\ndef make_beta(alpha, beta):\n  \"\"\"Makes a beta object.\"\"\"\n    dist = scipy.stats.beta(alpha, beta)\n    dist.alpha = alpha\n    dist.beta = beta\n    return dist \n```", "```py\nalpha = 1\nbeta = 1\n\nprior_beta = make_beta(alpha, beta) \n```", "```py\ndef update_beta(prior, data):\n  \"\"\"Update a beta distribution.\"\"\"\n    k, n = data\n    alpha = prior.alpha + k\n    beta = prior.beta + n - k\n    return make_beta(alpha, beta) \n```", "```py\ndata = 140, 250\nposterior_beta = update_beta(prior_beta, data) \n```", "```py\nposterior_conjugate = pmf_from_dist(posterior_beta, xs) \n```", "```py\ndef decorate_euro(title):\n    decorate(xlabel='Proportion of heads (x)',\n             ylabel='Probability',\n             title=title) \n```", "```py\nposterior.plot(label='grid posterior', color='C1')\nposterior_conjugate.plot(label='conjugate posterior',\n                        color='C4', ls=':')\n\ndecorate_euro(title='Posterior distribution of x') \n```", "```py\nnp.allclose(posterior, posterior_conjugate) \n```", "```py\nTrue \n```", "```py\nfrom scipy.stats import multinomial\n\ndata = 3, 2, 1\nn = np.sum(data)\nps = 0.4, 0.3, 0.3\n\nmultinomial.pmf(data, n, ps) \n```", "```py\n0.10368 \n```", "```py\nfrom scipy.stats import dirichlet\n\nalpha = 1, 2, 3\ndist = dirichlet(alpha) \n```", "```py\ndist.rvs() \n```", "```py\narray([[0.53566485, 0.35129   , 0.11304515]]) \n```", "```py\ndist.rvs().sum() \n```", "```py\n1.0 \n```", "```py\nsample = dist.rvs(1000) \n```", "```py\nsample.shape \n```", "```py\n(1000, 3) \n```", "```py\nfrom empiricaldist import Cdf\n\ncdfs = [Cdf.from_seq(col) \n        for col in sample.transpose()] \n```", "```py\nfor i, cdf in enumerate(cdfs):\n    label = f'Column {i}'\n    cdf.plot(label=label)\n\ndecorate() \n```", "```py\ndef marginal_beta(alpha, i):\n  \"\"\"Compute the ith marginal of a Dirichlet distribution.\"\"\"\n    total = np.sum(alpha)\n    return make_beta(alpha[i], total-alpha[i]) \n```", "```py\nmarginals = [marginal_beta(alpha, i)\n             for i in range(len(alpha))] \n```", "```py\nxs = np.linspace(0, 1, 101)\n\nfor i in range(len(alpha)):\n    label = f'Column {i}'\n\n    pmf = pmf_from_dist(marginals[i], xs)\n    pmf.make_cdf().plot(color='C5')\n\n    cdf = cdfs[i]\n    cdf.plot(label=label, ls=':')\n\ndecorate() \n```", "```py\n# Solution\n\n\"\"\"\nThe unnormalized posterior is\n\n\\lambda^{\\alpha-1+1} e^{-(\\beta + t) \\lambda}\n\nwhich is an unnormalized gamma distribution with parameters\n`alpha+1` and `beta+t`, which means that we observed 1 goal\nin elapsed time `t`.\n\nSo we can use the same update function and call it like this:\n\"\"\"\n\ndata = 1, 11/90\nposterior1 = update_gamma(prior_gamma, data) \n```", "```py\n# Solution\n\n# Here's the second update\n\ndata = 1, 12/90\nposterior2 = update_gamma(posterior1, data) \n```", "```py\n# Solution\n\nprior_gamma.mean(), posterior1.mean(), posterior2.mean() \n```", "```py\n(1.4, 2.1386138613861387, 2.7079646017699113) \n```", "```py\n# Solution\n\n# And here's what the posteriors look like\n\npmf_from_dist(prior_gamma, lams).plot(color='C5', label='prior')\npmf_from_dist(posterior1, lams).plot(label='after 1 goal')\npmf_from_dist(posterior2, lams).plot(label='after 2 goals')\n\ndecorate_rate(title='World Cup Problem, Germany v Brazil') \n```", "```py\nfrom empiricaldist import Pmf\n\nramp_up = np.arange(50)\nramp_down = np.arange(50, -1, -1)\n\na = np.append(ramp_up, ramp_down)\nxs = uniform.qs\n\ntriangle = Pmf(a, xs, name='triangle')\ntriangle.normalize() \n```", "```py\n2500 \n```", "```py\nk, n = 140, 250\nlikelihood = binom.pmf(k, n, xs)\n\nposterior = triangle * likelihood\nposterior.normalize() \n```", "```py\n0.007008842590059086 \n```", "```py\nalpha = 1\nbeta = 1\n\nprior_beta = make_beta(alpha, beta)\nprior_beta.mean() \n```", "```py\n0.5 \n```", "```py\nprior_pmf = pmf_from_dist(prior_beta, xs)\n\ntriangle.plot(label='triangle')\nprior_pmf.plot(label='beta')\n\ndecorate_euro('Prior distributions') \n```", "```py\n# Solution\n\ndata = 140, 250\nposterior_beta = update_beta(prior_beta, data)\nposterior_beta.mean() \n```", "```py\n0.5595238095238095 \n```", "```py\n# Solution\n\nposterior_conjugate = pmf_from_dist(posterior_beta, xs) \n```", "```py\n# Solution\n\nposterior.plot(label='grid posterior', ls=':')\nposterior_conjugate.plot(label='conjugate posterior')\n\ndecorate(xlabel='Proportion of heads (x)',\n         ylabel='Probability',\n         title='Posterior distribution of x') \n```", "```py\n# Solution\n\n# The largest absolute difference is pretty small\n\nnp.allclose(posterior, posterior_conjugate) \n```", "```py\nFalse \n```", "```py\n# Solution\n\n# The first prior implies that most sellers are \n# satisfactory most of the time, but none are perfect.\n\nprior = make_beta(8, 2)\n\nxs = np.linspace(0.005, 0.995, 199)\nprior_pmf = pmf_from_dist(prior, xs)\nprior_pmf.plot(color='C5', label='prior')\n\ndecorate(xlabel='Probability of positive rating',\n         ylabel='PDF') \n```", "```py\n# Solution\n\ndata1 = 10, 10\ndata2 = 48, 50\ndata3 = 186, 200 \n```", "```py\n# Solution\n\nseller1 = update_beta(prior, data1)\nseller2 = update_beta(prior, data2)\nseller3 = update_beta(prior, data3) \n```", "```py\n# Solution\n\nseller1_pmf = pmf_from_dist(seller1, xs)\nseller2_pmf = pmf_from_dist(seller2, xs)\nseller3_pmf = pmf_from_dist(seller3, xs) \n```", "```py\n# Solution\n\nseller1_pmf.plot(label='seller 1')\nseller2_pmf.plot(label='seller 2')\nseller3_pmf.plot(label='seller 3')\n\ndecorate(xlabel='Probability of positive rating',\n         ylabel='PDF',\n         xlim=(0.65, 1.0)) \n```", "```py\n# Solution\n\nseller1.mean(), seller2.mean(), seller3.mean() \n```", "```py\n(0.9, 0.9333333333333333, 0.9238095238095239) \n```", "```py\n# Solution\n\niters = 10000\na = np.empty((3, iters))\n\na[0] = seller1.rvs(iters)\na[1] = seller2.rvs(iters)\na[2] = seller3.rvs(iters) \n```", "```py\n# Solution\n\nfrom empiricaldist import Pmf\n\nbest = np.argmax(a, axis=0)\nPmf.from_seq(best) \n```", "```py\n# Solution\n\nprior_alpha = np.array([1, 1, 1])\ndata = 3, 2, 1 \n```", "```py\n# Solution\n\nposterior_alpha = prior_alpha + data \n```", "```py\n# Solution\n\nmarginal_bear = marginal_beta(posterior_alpha, 2)\nmarginal_bear.mean() \n```", "```py\n0.2222222222222222 \n```", "```py\n# Solution\n\ndist = dirichlet(posterior_alpha) \n```", "```py\n# Solution\n\nimport pandas as pd\n\nindex = ['lion', 'tiger', 'bear']\npd.DataFrame(dist.mean(), index, columns=['prob']) \n```"]