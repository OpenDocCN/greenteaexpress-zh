["```py\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \n```", "```py\nks = np.arange(101)\nns = np.arange(101)\nps = np.linspace(0, 1, 101) \n```", "```py\nfrom scipy.stats import binom\n\nK, N, P = np.meshgrid(ks, ns, ps, indexing='ij')\ncube = binom.pmf(K, N, P)\ncube.shape \n```", "```py\n(101, 101, 101) \n```", "```py\nn = 50\np = 50\npmf_k = cube[:, n, p] \n```", "```py\npmf_k.sum() \n```", "```py\n0.9999999999999996 \n```", "```py\nplt.plot(ks, pmf_k)\nplt.xlabel('k')\nplt.ylabel('PMF')\nplt.title('Binomial distribution of $k$'); \n```", "```py\npmf_binom = binom.pmf(ks, n, p/100) \n```", "```py\nnp.allclose(pmf_k, pmf_binom) \n```", "```py\nTrue \n```", "```py\nk = 25\np = 50\npmf_n = cube[k, :, p].copy() \n```", "```py\nnp.seterr(divide='ignore', invalid='ignore')\n\npmf_n /= (ns / k)\npmf_n[0] = 0 \n```", "```py\npmf_n /= pmf_n.sum() \n```", "```py\nplt.plot(ns, pmf_n)\nplt.xlabel('n')\nplt.ylabel('PMF')\nplt.title('Negative binomial distribution of $n$'); \n```", "```py\nfrom scipy.stats import nbinom\n\npmf_nbinom = nbinom.pmf(ns-k, k, p/100)\npmf_nbinom.sum() \n```", "```py\n0.9999999094998685 \n```", "```py\nnp.allclose(pmf_n, pmf_nbinom) \n```", "```py\nTrue \n```", "```py\nk = 25\nn = 50\n\npdf_p = cube[k, n, :].copy() \n```", "```py\npdf_p.sum() \n```", "```py\n1.96078431372549 \n```", "```py\npdf_p /= pdf_p.sum() \n```", "```py\nplt.plot(ps, pdf_p)\nplt.xlabel('p')\nplt.ylabel('PMF')\nplt.title('Beta distribution of $p$'); \n```", "```py\nfrom scipy.stats import beta\n\na = k + 1\nb = n - k + 1\na, b \n```", "```py\n(26, 26) \n```", "```py\npdf_beta = beta.pdf(ps, a, b)\npdf_beta /= pdf_beta.sum() \n```", "```py\nnp.allclose(pdf_p, pdf_beta) \n```", "```py\nTrue \n```", "```py\na = 2\nb = 3\n\nprior = beta.pdf(ps, a, b) \n```", "```py\nk = 5\nn = 10\n\nlike = binom.pmf(k, n, ps) \n```", "```py\nposterior = prior * like\nposterior /= posterior.sum() \n```", "```py\nposterior_beta = beta.pdf(ps, a+k, b+n-k)\nposterior_beta /= posterior_beta.sum() \n```", "```py\nnp.allclose(posterior, posterior_beta) \n```", "```py\nTrue \n```", "```py\ndef get_beta(a, b, cube):\n    k = a - 1\n    n = b + k - 1\n\n    pdf = cube[k, n, :].copy()\n    pdf /= pdf.sum()\n    return pdf \n```", "```py\nposterior_cube = get_beta(a + k, b + n - k, cube) \n```", "```py\nnp.allclose(posterior_beta, posterior_cube) \n```", "```py\nTrue \n```", "```py\nplt.plot(ps, posterior_cube)\n\nplt.xlabel('p')\nplt.ylabel('PMF')\nplt.title('Posterior distribution of p'); \n```", "```py\nlike2 = nbinom.pmf(n-k, k, ps)\nlike2[0] = 0 \n```", "```py\nposterior2 = prior * like2\nposterior2 /= posterior2.sum() \n```", "```py\nnp.allclose(posterior, posterior2) \n```", "```py\nTrue \n```", "```py\npost_pred_k = (cube[:, n, :] * posterior).sum(axis=1) \n```", "```py\nplt.bar(ks[:n+1], post_pred_k[:n+1])\n\nplt.xlabel('k')\nplt.ylabel('PMF')\nplt.title('Posterior predictive distribution of k'); \n```", "```py\nfrom scipy.stats import betabinom\n\npost_pred_bb = betabinom.pmf(ks, n, a+k, b+n-k) \n```", "```py\nnp.allclose(post_pred_k, post_pred_bb) \n```", "```py\nTrue \n```", "```py\nplane = cube[k, :, :] / ns[:, None]\nplane[0] = 0 \n```", "```py\npost_pred_n = (plane * posterior).sum(axis=1)\npost_pred_n /= post_pred_n.sum() \n```", "```py\nplt.plot(ns, post_pred_n)\n\nplt.xlabel('n')\nplt.ylabel('PMF')\nplt.title('Posterior predictive distribution of n'); \n```", "```py\nimport scipy.special as sps\n\ndef betanegbinom_pmf(n, r, a, b):\n  \"\"\"Compute the PMF of the beta-negative binomial distribution.\n\n Generated by ChatGPT, revised based on\n https://en.wikipedia.org/wiki/Beta_negative_binomial_distribution\n\n Parameters:\n - n: Number of trials before stopping.\n - r: Number of successes required.\n - a: Shape parameter of the beta distribution.\n - b: Shape parameter of the beta distribution.\n\n Returns:\n - PMF value for the given parameters.\n \"\"\"\n    k = n - r\n    binomial_coefficient = sps.comb(r + k - 1, k)\n    beta_num = sps.beta(a + r, b + k)\n    beta_den = sps.beta(a, b)\n\n    pmf = binomial_coefficient * (beta_num / beta_den)\n    return pmf \n```", "```py\npost_pred_bnb = betanegbinom_pmf(ns, k, a+k, b+n-k)\npost_pred_bnb /= post_pred_bnb.sum() \n```", "```py\nnp.allclose(post_pred_n, post_pred_bnb) \n```", "```py\nTrue \n```"]