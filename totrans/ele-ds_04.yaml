- en: Times and Places
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ElementsOfDataScience/02_times.html](https://allendowney.github.io/ElementsOfDataScience/02_times.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Run this notebook on Colab](https://colab.research.google.com/github/AllenDowney/ElementsOfDataScience/blob/master/02_times.ipynb)
    or'
  prefs: []
  type: TYPE_NORMAL
- en: '[Run this notebook on Sagemaker Studio Lab](https://studiolab.sagemaker.aws/import/github/AllenDowney/ElementsOfDataScience/blob/master/02_times.ipynb)
    or'
  prefs: []
  type: TYPE_NORMAL
- en: '[Download this notebook](https://github.com/AllenDowney/ElementsOfDataScience/raw/master/02_times.ipynb).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned about variables and two kinds of values:
    integers and floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll see some additional types:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings, which represent text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time stamps, which represent dates and times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And several ways to represent and display geographical locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not every data science project uses all of these types, but many projects use
    at least one.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **string** is a sequence of letters, numbers, and punctuation marks. In Python
    you can create a string by enclosing text between single or double quotation marks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And you can assign string values to variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Some arithmetic operators work with strings, but they might not do what you
    expect. For example, the `+` operator **concatenates** two strings; that is, it
    creates a new string that contains the first string followed by the second string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to put a space between the words, you can use a string that contains
    a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Strings are used to store text data like names, addresses, titles, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you read data from a file, you might see values that look like numbers,
    but they are actually strings, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you try to do math with these strings, you *might* get an error. For example,
    the following expression causes a `TypeError` with the message “can only concatenate
    `str` (not `int`) to `str`”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But you don’t always get an error message; instead, you might get a surprising
    result. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you multiply a string by an integer, Python repeats the string the given
    number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a string that contains only digits, you can convert it to an integer
    using the `int` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can convert it to a floating-point number using `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: But if the string contains a decimal point, you can’t convert it to an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going in the other direction, you can convert any type of value to a string
    using `str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise**: When personal names are stored in a database, they are often
    stored in three variables: a given name, a family name, and sometimes a middle
    name. For example, a list of great rock drummers might include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But names are often displayed different ways in different contexts. For example,
    the first time you mention someone in an article, you might give all three names,
    like “Neil Ellwood Peart”. But in the index of a book, you might put the family
    name first, like “Peart, Neil Ellwood”.
  prefs: []
  type: TYPE_NORMAL
- en: Write Python expressions that use the variables `given`, `middle`, and `family`
    to display Neil Peart’s name in these two formats.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Dates and Times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you read data from a file, you might also find that dates and times are represented
    with strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To confirm that this value is a string, we can use the `type` function, which
    takes a value and reports its type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`str` indicates that the value of `not_really_a_date` is a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the same result with `not_really_a_time`, below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Strings that represent dates and times a readable for people, but they are not
    useful for computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Python provides libraries for working with date and time data;
    the one we’ll use is called Pandas. As always, we have to import a library before
    we use it; it is conventional to import Pandas with the abbreviated name `pd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Pandas provides a type called `Timestamp`, which represents a date and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also provides a function called `Timestamp`, which we can use to convert
    a string to a `Timestamp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Or we can do the same thing using the variable defined above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the string specifies a time but no date, so Pandas fills in
    today’s date.
  prefs: []
  type: TYPE_NORMAL
- en: A `Timestamp` is a value, so you can assign it to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If the string specifies a date but no time, Pandas fills in midnight as the
    default time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you assign the `Timestamp` to a variable, you can use the variable name
    to get the year, month, and day, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can also get the name of the month and the day of the week.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`Timestamp` provides a function called `now` that returns the current date
    and time.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise:** Use the value of `now` to display the name of the current month
    and day of the week.'
  prefs: []
  type: TYPE_NORMAL
- en: Timedelta
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Timestamp` values support some arithmetic operations. For example, you can
    compute the difference between two `Timestamp` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The result is a `Timedelta` that represents the current age of someone born
    on `date_of_birth`. The `Timedelta` contains `components` that store the number
    of days, hours, etc. between the two `Timestamp` values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get one of the components like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The biggest component of `Timedelta` is days, not years, because days are well
    defined and years are problematic.
  prefs: []
  type: TYPE_NORMAL
- en: Most years are 365 days, but some are 366\. The average calendar year is 365.24
    days, which is a very good approximation of a solar year, but it is not exact
    (see [https://pumas.jpl.nasa.gov/files/04_21_97_1.pdf](https://pumas.jpl.nasa.gov/files/04_21_97_1.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to compute age in years is to divide age in days by 365.24:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'But people usually report their ages in integer years. We can use the Numpy
    `floor` function to round down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the `ceil` function (which stands for “ceiling”) to round up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can also compare `Timestamp` values to see which comes first. For example,
    let’s see if a person with a given birthdate has already had a birthday this year.
    Here’s a new `Timestamp` with the year from `now` and the month and day from `date_of_birth`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result represents the person’s birthday this year. Now we can use the `>`
    operator to check whether `now` is later than the birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The result is either `True` or `False`. These values belong to a type called
    `bool`; the name comes from “Boolean algebra”, which is a branch of algebra where
    all values are either true or false.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise:** Any two people with different birthdays have a “Double Day” when
    one is twice as old as the other. Suppose you are given two `Timestamp` values,
    `d1` and `d2`, that represent birthdays for two people. Use `Timestamp` arithmetic
    to compute their double day. With the following dates, the result should be December
    19, 2009.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Representing Location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to times and dates, we might also want to represent locations, especially
    if we are working with geographical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to represent locations, but the most common, at least for
    global data, is latitude and longitude. When stored as strings, latitude and longitude
    are expressed in degrees with compass directions N, S, E, and W. For example,
    this string represents the location of Boston, MA, USA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When we compute with location information, we use floating-point numbers, with
  prefs: []
  type: TYPE_NORMAL
- en: Positive latitude for the northern hemisphere, negative latitude for the southern
    hemisphere, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positive longitude for the eastern hemisphere and negative longitude for the
    western hemisphere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the choice of the origin and the orientation of positive and negative
    are arbitrary choices that were made for historical reasons. We might not be able
    to change conventions like these, but we should be aware that they are conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how we might represent the location of Boston with two variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to combine two numbers into a composite value and assign
    it to a single variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The type of this variable is `tuple`, which is a mathematical term for a value
    that contains a sequence of elements. Math people pronounce it “tuh’ ple”, but
    computational people usually say “too’ ple”. Take your pick.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a tuple with two elements, you can assign them to two variables,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I assigned latitude to `y` and longitude to `x`, because a `y` coordinate
    usually goes up and down like latitude, and an `x` coordinate usually goes side-to-side
    like longitude.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Find the latitude and longitude of the place you were born or
    someplace you think of as your “home town”. [You can use this web page to look
    it up](https://www.latlong.net/). Make a tuple of floating-point numbers that
    represents that location.'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are given two tuples that represent locations, you can compute the approximate
    distance between them, along the surface of the globe, using the haversine function.
    If you are curious about it, [you can read an explanation in this article](https://janakiev.com/blog/gps-points-distance-python/).
    To estimate a haversine distance, we have to compute the haversine function, which
    is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: \(\mathrm{haversine}(\theta)=\sin^2(\theta/2)\)
  prefs: []
  type: TYPE_NORMAL
- en: 'Where \(\theta\) is an angle in radians. We can compute this function in Python
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You can use Greek letters in variable names, but there is currently no way to
    type them in Jupyter/Colab, so I usually copy them from a web page and paste them
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the inconvenience, it is more common to write out letter names, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the operator for exponentiation is `**`.
  prefs: []
  type: TYPE_NORMAL
- en: In some other languages it’s `^`, which is also an operator in Python, but it
    performs another operation altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we are planning to use an expression like `np.sin(theta/2)**2` more than
    a few times, we can define a new function that computes it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, `def` indicates that we are defining a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line is a triple-quoted string, which is a **comment**: it describes
    what the function does, but has no effect when the program runs.'
  prefs: []
  type: TYPE_NORMAL
- en: On the third line, `return` indicates the result of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the previous cell, it creates a new variable called `haversine`.
    You can display its value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can display its type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'So `haversine` is a variable that refers to a function. To run the function
    and compute a result, we have to **call** the function and provide a value for
    `theta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: When you define a function, you create a new variable. But the function doesn’t
    actually run until you call it.
  prefs: []
  type: TYPE_NORMAL
- en: Haversine Distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can use `haversine` as part of a function that computes haversine distances.
    I won’t explain this function in as much detail, but if you read through it, you
    might get a sense of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call this function, we provide two tuples; each is a latitude-longitude
    pair. We already have a tuple that represents the location of Boston. Now here’s
    a tuple that represents the location of London, England, UK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: And here’s the haversine distance between Boston and London.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The actual geographic distance is slightly different because Earth is not a
    perfect sphere. But the error of this estimate is less than 1%.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Use `haversine_distance` to compute the distance between Boston
    and your home town from the previous exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: If possible, use an online map to check the result.
  prefs: []
  type: TYPE_NORMAL
- en: Geopandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides libraries for working with geographical data. One of the most
    popular is Geopandas, which is based on another library called Shapely. Shapely
    provides `Point` and `LineString` values, which we’ll use to represent geographic
    locations and lines between them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We can use the tuples we defined in the previous section to create Shapely `Point`
    values, but we have to reverse the order of the coordinates, providing them in
    \(x\)-\(y\) order rather than `lat`-`lon` order, because that’s the order the
    `Point` function expects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the points we just defined to create a `LineString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use Geopandas to show these points and lines on a map. The following
    code loads a map of the world and plots it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: By default, Geopandas uses an equirectangular projection, which provides a misleading
    picture of relative land areas (see [https://en.wikipedia.org/wiki/Equirectangular_projection](https://en.wikipedia.org/wiki/Equirectangular_projection)).
    You can’t make a map without making visualization decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s put dots on the map for Boston and London. We have to put the `Point`
    values and the `LineString` into a `GeoSeries`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a first attempt to plot the maps and the lines together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/02_times_133_0.png](../Images/07a5b4ee8bd995963f36fa3fe983105e.png)
    ![_images/02_times_133_1.png](../Images/3e9084ac867903b0a9279d8513c75293.png)'
  prefs: []
  type: TYPE_IMG
- en: The two plots are on different axes, which is not what we want in this case.
  prefs: []
  type: TYPE_NORMAL
- en: To get the points and the map on the same axes, we have to use a function from
    Matplotlib, which is a visualization library we will use extensively. We’ll import
    it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The function is `gca`, which stands for “get current axes”. We can use the result
    to tell `plot` to put the points and lines on the current axes, rather than create
    a new one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/02_times_137_0.png](../Images/81fa0bef649e15f70a76f8f71ad31dd0.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Exercise:** Modify the code in this section to plot a point that shows the
    home town you chose in a previous exercise and a line from there to Boston.'
  prefs: []
  type: TYPE_NORMAL
- en: Then go to [this online survey](https://forms.gle/2LDcqxJmcWY3Q3X47) and answer
    the questions there.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter presents three new data types: strings to represent letters and
    words, `Timestamp` objects to represent dates and times, and tuples to represent
    latitude, longitude pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: It also introduces Geopandas, a library for working with location data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we’ll see two ways to represent a collection of data, a
    Python list and a Numpy array.
  prefs: []
  type: TYPE_NORMAL
