- en: PageRank
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/DSIRP/pagerank.html](https://allendowney.github.io/DSIRP/pagerank.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Click here to run this notebook on Colab](https://colab.research.google.com/github/AllenDowney/DSIRP/blob/main/notebooks/pagerank.ipynb)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Ranking pages
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of information retrieval is to find resources that are relevant and
    high quality. “Relevant” and “quality” can be hard to define, and they depend
    on what kind of resources you are searching.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of web search, relevance usually depends on the contents of
    a web page: if a web page contains the search terms, we assume that it is relevant
    to the search terms.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Quality usually depends on the links between pages. If there are many links
    to a particular page, we think it is more likely to be high quality, especially
    if those links come from pages that are high quality themselves.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: One of the first algorithms to quantify quality in this is PageRank, which was
    the core of Google’s original search engine. As someone who used earlier search
    engines, like Alta Vista, I can tell you first-hand what a big difference it made.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'PageRank is described in [“The PageRank citation ranking: Bringing order to
    the Web”](https://web.archive.org/web/20110818093436/http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf)
    by Page, Brin, Motwani, and Winograd.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: It is a surprisingly simple algorithm; it can be computed and updated efficiently;
    and it is highly effective at identifying good quality pages. So, let’s see how
    it works.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, I’ll use `random_k_out_graph` to generate a directed graph with
    `n` nodes where:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Every node has the same number of out-links, `k`,
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of in-links varies moderately (controlled by the parameter `alpha`).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-links and multiple links are allowed.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here’s what the graph looks like. Multiple links appear as slightly thicker
    lines.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![_images/pagerank_6_0.png](../Images/d2eeb27b59adfdff0e5831278f78fe33.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: NetworkX provides an implementation of PageRank we can use to compute a metric
    of “importance” for each page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should see that nodes with more in-links get higher scores.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Random Walk
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to interpret PageRank is in terms of a random walk. Suppose you choose
    a node at random, then choose one of its out-links at random, and continue like
    that, making a note of each node you visit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: If a node has a lot of in-links, you are likely to visit it more often. And
    if those in-links come from nodes with many in-links, even more so.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one catch: if a node contains no out-links, or if a set of
    nodes form a loop with no out-links, the random walker could get trapped.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: To avoid that, we’ll modify the random walk so at every step there is some probability
    that the walker jumps to a random node rather than following a link. This probability
    is determined by a parameter, `alpha`, which is the probability of following a
    link, so `1-alpha` is the probability of making a random jump.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The following function implements a random walk, with these random jumps, and
    uses a `Counter` to keep track of the number of times it visits each node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: It returns the `Counter` with the frequencies normalized to add up to one. If
    everything goes according to plan, these values should approximate the results
    from PageRank.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The default value of `alpha` is 0.85, which is the same as the default value
    for `nx.pagerank`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Here are the scores we get from the random walk.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To compare them to the results from PageRank, I’ll put them in a Pandas `DataFrame`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  | PageRank | RandomWalk | Diff |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| 0 | 15.292146 | 13.3 | -1.992146 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| 1 | 37.078963 | 39.0 | 1.921037 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| 2 | 14.402453 | 14.5 | 0.097547 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.875000 | 0.9 | -0.975000 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| 4 | 18.430401 | 19.0 | 0.569599 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1.875000 | 2.1 | 0.225000 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1.875000 | 1.9 | 0.025000 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| 7 | 9.171037 | 9.3 | 0.128963 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: The differences should be a few percentage points at most.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency Matrix
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The random walk implementation of PageRank is conceptually simple, but not very
    efficient to compute. An alternative is to use a matrix to represent the links
    from each node to every other node, and compute the eigenvectors of that matrix.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll demonstrate this computation and explain how it works.
    The code here is based on the [implementation of PageRank in NetworkX](https://networkx.org/documentation/stable/_modules/networkx/algorithms/link_analysis/pagerank_alg.html).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX provides a function that creates a NumPy array that represents the
    [adjacency matrix](https://en.wikipedia.org/wiki/Adjacency_matrix) of the graph.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this matrix, the element in row `i`, column `j` indicates the number of edges
    from node `i` to node `j`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: If we normalize each row so it adds up to one, each element of the result represents
    the probability of a transition from one node to another.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use this matrix to simulate a random walk with many walkers at the same
    time. For example, suppose we start with 100 walkers at each node, represented
    by the array `x`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we transpose `M`, we get a [transition matrix](https://en.wikipedia.org/wiki/Stochastic_matrix)
    where the element at row `i` and column `j` is the fraction of walkers at node
    `j` that move to node `i`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: If we multiply the transition matrix by `x`, the result is an array with the
    number of walkers at each node after one time step.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you run that cell a few times, you should find that it converges to a steady
    state where the number of walkers at each node doesn’t change much from one time
    step to the next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: However, you might notice that some nodes lose all of their walkers. That’s
    because the random walk we’ve simulated doesn’t include random jumps.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To add random jumps, we can create another matrix that include transitions from
    all nodes to all other nodes with equal probability.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we’ll use the parameter `alpha` to compute a weighted sum of `M` and `p`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The result is a “Google matrix” that represents transitions in a random walk,
    including random jumps.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: So let’s start again with an equal number of walkers on all nodes and simulate
    10 time steps.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we normalize `x` so it adds up to one, the result should approximate the
    ranks we got from PageRank.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here’s the table that compares the results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  | PageRank | AdjMatrix | Diff |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| 0 | 15.292146 | 15.293199 | 0.001053 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| 1 | 37.078963 | 37.077494 | -0.001469 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| 2 | 14.402453 | 14.404034 | 0.001581 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.875000 | 1.875000 | 0.000000 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| 4 | 18.430401 | 18.427767 | -0.002634 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1.875000 | 1.875000 | 0.000000 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1.875000 | 1.875000 | 0.000000 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| 7 | 9.171037 | 9.172506 | 0.001469 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: Eigenvectors
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you start with almost any vector and multiply by a matrix repeatedly, as
    we did in the previous section, the result will converge to the eigenvector of
    the matrix that corresponds to the largest eigenvalue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, repeated multiplication is one of the algorithms used to compute eigenvalues:
    it is called [power iteration](https://en.wikipedia.org/wiki/Power_iteration).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using an iterative method, we can also compute eigenvalues directly,
    which is what the Numpy function `eig` does. Here are the eigenvalues and eigenvectors
    of the Google matrix.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And here’s how we can get the eigenvector corresponding to the largest eigenvalue.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The result contains complex numbers, but the imaginary parts are all 0, so we
    can pull out just the real part.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And normalize it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result is the set of ranks based on the eigenvectors of the Google matrix.
    They should be identical to the results from PageRank, except for small floating-point
    errors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  | PageRank | Eigenvector | Diff |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| 0 | 15.292146 | 15.292059 | -8.752734e-05 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| 1 | 37.078963 | 37.079000 | 3.719912e-05 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| 2 | 14.402453 | 14.402491 | 3.839473e-05 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.875000 | 1.875000 | 1.734723e-15 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| 4 | 18.430401 | 18.430450 | 4.913262e-05 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1.875000 | 1.875000 | 1.040834e-15 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1.875000 | 1.875000 | 1.040834e-15 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1.875000 | 1.875000 | 1.040834e-15 |'
- en: '| 7 | 9.171037 | 9.171000 | -3.719912e-05 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 9.171037 | 9.171000 | -3.719912e-05 |'
- en: Putting it all together
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: The following are simplified versions of the NetworkX functions that compute
    the Google matrix and the PageRank scores.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是计算 Google 矩阵和 PageRank 分数的 NetworkX 函数的简化版本。
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Data Structures and Information Retrieval in Python*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 中的数据结构和信息检索*'
- en: Copyright 2021 Allen Downey
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 2021 年 Allen Downey
- en: 'License: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证：[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)
