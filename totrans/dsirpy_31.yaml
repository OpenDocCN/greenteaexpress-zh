- en: PageRank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/DSIRP/pagerank.html](https://allendowney.github.io/DSIRP/pagerank.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Click here to run this notebook on Colab](https://colab.research.google.com/github/AllenDowney/DSIRP/blob/main/notebooks/pagerank.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: Ranking pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of information retrieval is to find resources that are relevant and
    high quality. “Relevant” and “quality” can be hard to define, and they depend
    on what kind of resources you are searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of web search, relevance usually depends on the contents of
    a web page: if a web page contains the search terms, we assume that it is relevant
    to the search terms.'
  prefs: []
  type: TYPE_NORMAL
- en: Quality usually depends on the links between pages. If there are many links
    to a particular page, we think it is more likely to be high quality, especially
    if those links come from pages that are high quality themselves.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first algorithms to quantify quality in this is PageRank, which was
    the core of Google’s original search engine. As someone who used earlier search
    engines, like Alta Vista, I can tell you first-hand what a big difference it made.
  prefs: []
  type: TYPE_NORMAL
- en: 'PageRank is described in [“The PageRank citation ranking: Bringing order to
    the Web”](https://web.archive.org/web/20110818093436/http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf)
    by Page, Brin, Motwani, and Winograd.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a surprisingly simple algorithm; it can be computed and updated efficiently;
    and it is highly effective at identifying good quality pages. So, let’s see how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, I’ll use `random_k_out_graph` to generate a directed graph with
    `n` nodes where:'
  prefs: []
  type: TYPE_NORMAL
- en: Every node has the same number of out-links, `k`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of in-links varies moderately (controlled by the parameter `alpha`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-links and multiple links are allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what the graph looks like. Multiple links appear as slightly thicker
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/pagerank_6_0.png](../Images/d2eeb27b59adfdff0e5831278f78fe33.png)'
  prefs: []
  type: TYPE_IMG
- en: NetworkX provides an implementation of PageRank we can use to compute a metric
    of “importance” for each page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should see that nodes with more in-links get higher scores.
  prefs: []
  type: TYPE_NORMAL
- en: Random Walk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to interpret PageRank is in terms of a random walk. Suppose you choose
    a node at random, then choose one of its out-links at random, and continue like
    that, making a note of each node you visit.
  prefs: []
  type: TYPE_NORMAL
- en: If a node has a lot of in-links, you are likely to visit it more often. And
    if those in-links come from nodes with many in-links, even more so.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one catch: if a node contains no out-links, or if a set of
    nodes form a loop with no out-links, the random walker could get trapped.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid that, we’ll modify the random walk so at every step there is some probability
    that the walker jumps to a random node rather than following a link. This probability
    is determined by a parameter, `alpha`, which is the probability of following a
    link, so `1-alpha` is the probability of making a random jump.
  prefs: []
  type: TYPE_NORMAL
- en: The following function implements a random walk, with these random jumps, and
    uses a `Counter` to keep track of the number of times it visits each node.
  prefs: []
  type: TYPE_NORMAL
- en: It returns the `Counter` with the frequencies normalized to add up to one. If
    everything goes according to plan, these values should approximate the results
    from PageRank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The default value of `alpha` is 0.85, which is the same as the default value
    for `nx.pagerank`.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the scores we get from the random walk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To compare them to the results from PageRank, I’ll put them in a Pandas `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|  | PageRank | RandomWalk | Diff |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 15.292146 | 13.3 | -1.992146 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 37.078963 | 39.0 | 1.921037 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 14.402453 | 14.5 | 0.097547 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.875000 | 0.9 | -0.975000 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 18.430401 | 19.0 | 0.569599 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1.875000 | 2.1 | 0.225000 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1.875000 | 1.9 | 0.025000 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 9.171037 | 9.3 | 0.128963 |'
  prefs: []
  type: TYPE_TB
- en: The differences should be a few percentage points at most.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The random walk implementation of PageRank is conceptually simple, but not very
    efficient to compute. An alternative is to use a matrix to represent the links
    from each node to every other node, and compute the eigenvectors of that matrix.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll demonstrate this computation and explain how it works.
    The code here is based on the [implementation of PageRank in NetworkX](https://networkx.org/documentation/stable/_modules/networkx/algorithms/link_analysis/pagerank_alg.html).
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX provides a function that creates a NumPy array that represents the
    [adjacency matrix](https://en.wikipedia.org/wiki/Adjacency_matrix) of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this matrix, the element in row `i`, column `j` indicates the number of edges
    from node `i` to node `j`.
  prefs: []
  type: TYPE_NORMAL
- en: If we normalize each row so it adds up to one, each element of the result represents
    the probability of a transition from one node to another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this matrix to simulate a random walk with many walkers at the same
    time. For example, suppose we start with 100 walkers at each node, represented
    by the array `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we transpose `M`, we get a [transition matrix](https://en.wikipedia.org/wiki/Stochastic_matrix)
    where the element at row `i` and column `j` is the fraction of walkers at node
    `j` that move to node `i`.
  prefs: []
  type: TYPE_NORMAL
- en: If we multiply the transition matrix by `x`, the result is an array with the
    number of walkers at each node after one time step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you run that cell a few times, you should find that it converges to a steady
    state where the number of walkers at each node doesn’t change much from one time
    step to the next.
  prefs: []
  type: TYPE_NORMAL
- en: However, you might notice that some nodes lose all of their walkers. That’s
    because the random walk we’ve simulated doesn’t include random jumps.
  prefs: []
  type: TYPE_NORMAL
- en: To add random jumps, we can create another matrix that include transitions from
    all nodes to all other nodes with equal probability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll use the parameter `alpha` to compute a weighted sum of `M` and `p`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The result is a “Google matrix” that represents transitions in a random walk,
    including random jumps.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s start again with an equal number of walkers on all nodes and simulate
    10 time steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If we normalize `x` so it adds up to one, the result should approximate the
    ranks we got from PageRank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the table that compares the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|  | PageRank | AdjMatrix | Diff |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 15.292146 | 15.293199 | 0.001053 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 37.078963 | 37.077494 | -0.001469 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 14.402453 | 14.404034 | 0.001581 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.875000 | 1.875000 | 0.000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 18.430401 | 18.427767 | -0.002634 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1.875000 | 1.875000 | 0.000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1.875000 | 1.875000 | 0.000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 9.171037 | 9.172506 | 0.001469 |'
  prefs: []
  type: TYPE_TB
- en: Eigenvectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you start with almost any vector and multiply by a matrix repeatedly, as
    we did in the previous section, the result will converge to the eigenvector of
    the matrix that corresponds to the largest eigenvalue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, repeated multiplication is one of the algorithms used to compute eigenvalues:
    it is called [power iteration](https://en.wikipedia.org/wiki/Power_iteration).'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using an iterative method, we can also compute eigenvalues directly,
    which is what the Numpy function `eig` does. Here are the eigenvalues and eigenvectors
    of the Google matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And here’s how we can get the eigenvector corresponding to the largest eigenvalue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The result contains complex numbers, but the imaginary parts are all 0, so we
    can pull out just the real part.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And normalize it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The result is the set of ranks based on the eigenvectors of the Google matrix.
    They should be identical to the results from PageRank, except for small floating-point
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|  | PageRank | Eigenvector | Diff |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 15.292146 | 15.292059 | -8.752734e-05 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 37.078963 | 37.079000 | 3.719912e-05 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 14.402453 | 14.402491 | 3.839473e-05 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1.875000 | 1.875000 | 1.734723e-15 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 18.430401 | 18.430450 | 4.913262e-05 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 1.875000 | 1.875000 | 1.040834e-15 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1.875000 | 1.875000 | 1.040834e-15 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 9.171037 | 9.171000 | -3.719912e-05 |'
  prefs: []
  type: TYPE_TB
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are simplified versions of the NetworkX functions that compute
    the Google matrix and the PageRank scores.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Data Structures and Information Retrieval in Python*'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2021 Allen Downey
  prefs: []
  type: TYPE_NORMAL
- en: 'License: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
