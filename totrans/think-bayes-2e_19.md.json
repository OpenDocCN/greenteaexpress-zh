["```py\ndef prob(o):\n    return o / (o+1) \n```", "```py\nimport pandas as pd\n\nindex = ['prior', '1 student', '2 students', '3 students']\n\ntable = pd.DataFrame(index=index)\ntable['odds'] = [10, 10/3, 10/9, 10/27]\ntable['prob'] = prob(table['odds'])\ntable['prob diff'] = table['prob'].diff() * 100\ntable.fillna('--') \n```", "```py\nimport numpy as np\n\ntable['log odds'] = np.log(table['odds'])\ntable['log odds diff'] = table['log odds'].diff()\ntable.fillna('--') \n```", "```py\nnp.log(1/3) \n```", "```py\n-1.0986122886681098 \n```", "```py\ndownload('https://raw.githubusercontent.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/master/Chapter2_MorePyMC/data/challenger_data.csv') \n```", "```py\ndata = pd.read_csv('challenger_data.csv', parse_dates=[0])\n\n# avoiding column names with spaces\ndata.rename(columns={'Damage Incident': 'Damage'}, inplace=True)\n\n# dropping row 3, in which Damage Incident is NaN,\n# and row 24, which is the record for the Challenger\ndata.drop(labels=[3, 24], inplace=True)\n\n# convert the Damage column to integer\ndata['Damage'] = data['Damage'].astype(int)\n\ndata \n```", "```py\ndata.head() \n```", "```py\nlen(data), data['Damage'].sum() \n```", "```py\n(23, 7) \n```", "```py\nimport matplotlib.pyplot as plt\nfrom utils import decorate\n\ndef plot_data(data):\n  \"\"\"Plot damage as a function of temperature.\n\n data: DataFrame\n \"\"\"\n    plt.plot(data['Temperature'], data['Damage'], 'o', \n             label='data', color='C0', alpha=0.4)\n\n    decorate(ylabel=\"Probability of damage\",\n         xlabel=\"Outside temperature (deg F)\",\n         title=\"Damage to O-Rings vs Temperature\") \n```", "```py\nplot_data(data) \n```", "```py\noffset = data['Temperature'].mean().round()\ndata['x'] = data['Temperature'] - offset\noffset \n```", "```py\n70.0 \n```", "```py\ndata['y'] = data['Damage'] \n```", "```py\nimport statsmodels.formula.api as smf\n\nformula = 'y ~ x'\nresults = smf.logit(formula, data=data).fit(disp=False)\nresults.params \n```", "```py\nIntercept   -1.208490\nx           -0.232163\ndtype: float64 \n```", "```py\ninter = results.params['Intercept']\nslope = results.params['x']\nxs = np.arange(53, 83) - offset \n```", "```py\nlog_odds = inter + slope * xs \n```", "```py\nodds = np.exp(log_odds)\nps = odds / (odds + 1) \n```", "```py\nps.mean() \n```", "```py\n0.4155141126966854 \n```", "```py\nfrom scipy.special import expit\n\nps = expit(inter + slope * xs) \n```", "```py\nps.mean() \n```", "```py\n0.4155141126966854 \n```", "```py\nplt.plot(xs+offset, ps, label='model', color='C1')\n\nplot_data(data) \n```", "```py\nfrom utils import make_uniform\n\nqs = np.linspace(-5, 1, num=101)\nprior_inter = make_uniform(qs, 'Intercept') \n```", "```py\nqs = np.linspace(-0.8, 0.1, num=101)\nprior_slope = make_uniform(qs, 'Slope') \n```", "```py\nfrom utils import make_joint\n\njoint = make_joint(prior_inter, prior_slope) \n```", "```py\nfrom empiricaldist import Pmf\n\njoint_pmf = Pmf(joint.stack())\njoint_pmf.head() \n```", "```py\ngrouped = data.groupby('x')['y'].agg(['count', 'sum'])\ngrouped.head() \n```", "```py\nns = grouped['count']\nks = grouped['sum'] \n```", "```py\nxs = grouped.index\nps = expit(inter + slope * xs) \n```", "```py\nfrom scipy.stats import binom\n\nlikes = binom.pmf(ks, ns, ps)\nlikes \n```", "```py\narray([0.93924781, 0.85931657, 0.82884484, 0.60268105, 0.56950687,\n       0.24446388, 0.67790595, 0.72637895, 0.18815003, 0.8419509 ,\n       0.87045398, 0.15645171, 0.86667894, 0.95545945, 0.96435859,\n       0.97729671]) \n```", "```py\nlikes.prod() \n```", "```py\n0.0004653644508250066 \n```", "```py\nlikelihood = joint_pmf.copy()\nfor slope, inter in joint_pmf.index:\n    ps = expit(inter + slope * xs)\n    likes = binom.pmf(ks, ns, ps)\n    likelihood[slope, inter] = likes.prod() \n```", "```py\nposterior_pmf = joint_pmf * likelihood\nposterior_pmf.normalize() \n```", "```py\npd.Series(posterior_pmf.max_prob(),\n          index=['slope', 'inter']) \n```", "```py\nslope   -0.233\ninter   -1.220\ndtype: float64 \n```", "```py\nresults.params \n```", "```py\nIntercept   -1.208490\nx           -0.232163\ndtype: float64 \n```", "```py\nfrom utils import plot_contour\n\njoint_posterior = posterior_pmf.unstack()\nplot_contour(joint_posterior)\ndecorate(title='Joint posterior distribution') \n```", "```py\nfrom utils import marginal\n\nmarginal_inter = marginal(joint_posterior, 0)\nmarginal_slope = marginal(joint_posterior, 1) \n```", "```py\nmarginal_inter.plot(label='intercept', color='C4')\n\ndecorate(xlabel='Intercept',\n         ylabel='PDF',\n         title='Posterior marginal distribution of intercept') \n```", "```py\nmarginal_slope.plot(label='slope', color='C2')\n\ndecorate(xlabel='Slope',\n         ylabel='PDF',\n         title='Posterior marginal distribution of slope') \n```", "```py\npd.Series([marginal_inter.mean(), marginal_slope.mean()],\n          index=['inter', 'slope']) \n```", "```py\ninter   -1.376107\nslope   -0.289795\ndtype: float64 \n```", "```py\nresults.params \n```", "```py\nIntercept   -1.208490\nx           -0.232163\ndtype: float64 \n```", "```py\ndef transform(pmf, func):\n  \"\"\"Transform the quantities in a Pmf.\"\"\"\n    ps = pmf.ps\n    qs = func(pmf.qs)\n    return Pmf(ps, qs, copy=True) \n```", "```py\nmarginal_probs = transform(marginal_inter, expit) \n```", "```py\nmarginal_probs = marginal_inter.transform(expit) \n```", "```py\nmarginal_probs.plot(color='C1')\n\ndecorate(xlabel='Probability of damage at 70 deg F',\n         ylabel='PDF',\n         title='Posterior marginal distribution of probabilities') \n```", "```py\nmean_prob = marginal_probs.mean()\nmean_prob \n```", "```py\n0.2201937884647988 \n```", "```py\nmarginal_lr = marginal_slope.transform(np.exp) \n```", "```py\nmarginal_lr.plot(color='C3')\n\ndecorate(xlabel='Likelihood ratio of 1 deg F',\n         ylabel='PDF',\n         title='Posterior marginal distribution of likelihood ratios') \n```", "```py\nmean_lr = marginal_lr.mean()\nmean_lr \n```", "```py\n0.7542914170110268 \n```", "```py\nexpit(marginal_inter.mean()), marginal_probs.mean() \n```", "```py\n(0.2016349762400815, 0.2201937884647988) \n```", "```py\nnp.exp(marginal_slope.mean()), marginal_lr.mean() \n```", "```py\n(0.7484167954660071, 0.7542914170110268) \n```", "```py\nsample = posterior_pmf.choice(101) \n```", "```py\nsample.shape \n```", "```py\n(101,) \n```", "```py\nsample.dtype \n```", "```py\ndtype('O') \n```", "```py\ntype(sample[0]) \n```", "```py\ntuple \n```", "```py\ntemps = np.arange(31, 83)\nxs = temps - offset \n```", "```py\npred = np.empty((len(sample), len(xs)))\n\nfor i, (slope, inter) in enumerate(sample):\n    pred[i] = expit(inter + slope * xs) \n```", "```py\nfor ps in pred:\n    plt.plot(temps, ps, color='C1', lw=0.5, alpha=0.4)\n\nplot_data(data) \n```", "```py\nlow, median, high = np.percentile(pred, [5, 50, 95], axis=0) \n```", "```py\nplt.fill_between(temps, low, high, color='C1', alpha=0.2)\nplt.plot(temps, median, color='C1', label='logistic model')\n\nplot_data(data) \n```", "```py\nlow = pd.Series(low, temps)\nmedian = pd.Series(median, temps)\nhigh = pd.Series(high, temps) \n```", "```py\nt = 80\nprint(median[t], (low[t], high[t])) \n```", "```py\n0.016956535510200765 (0.000563939208692237, 0.1335417225332125) \n```", "```py\nt = 60\nprint(median[t], (low[t], high[t])) \n```", "```py\n0.7738185742694538 (0.45512110762641983, 0.9654437697137236) \n```", "```py\nt = 31\nprint(median[t], (low[t], high[t])) \n```", "```py\n0.9998129598124814 (0.97280101769455, 0.999999987740933) \n```", "```py\n# Solution\n\nprior_log_odds = np.log(4)\nprior_log_odds \n```", "```py\n1.3862943611198906 \n```", "```py\n# Solution\n\nlr1 = np.log(7/5)\nlr2 = np.log(3/5)\nlr3 = np.log(9/5)\n\nlr1, lr2, lr3 \n```", "```py\n(0.3364722366212129, -0.5108256237659907, 0.5877866649021191) \n```", "```py\n# Solution\n\n# In total, these three outcomes provide evidence that the\n# pundit's algorithm is legitmate, although with K=1.8,\n# it is weak evidence.\n\nposterior_log_odds = prior_log_odds + lr1 + lr2 + lr3\nposterior_log_odds \n```", "```py\n1.7997276388772319 \n```", "```py\nn = np.array([32690, 31238, 34405, 34565, 34977, 34415, \n                   36577, 36319, 35353, 34405, 31285, 31617])\n\nk = np.array([265, 280, 307, 312, 317, 287, \n                      320, 309, 225, 240, 232, 243]) \n```", "```py\nx = np.arange(12)\nn = np.roll(n, -8)\nk = np.roll(k, -8) \n```", "```py\nadhd = pd.DataFrame(dict(x=x, k=k, n=n))\nadhd['rate'] = adhd['k'] / adhd['n'] * 10000\nadhd \n```", "```py\ndef plot_adhd(adhd):\n    plt.plot(adhd['x'], adhd['rate'], 'o', \n             label='data', color='C0', alpha=0.4)\n\n    plt.axvline(5.5, color='gray', alpha=0.2)\n    plt.text(6, 64, 'Younger than average')\n    plt.text(5, 64, 'Older than average', horizontalalignment='right')\n\n    decorate(xlabel='Birth date, months after cutoff',\n             ylabel='Diagnosis rate per 10,000') \n```", "```py\nplot_adhd(adhd) \n```", "```py\nqs = np.linspace(-5.2, -4.6, num=51)\nprior_inter = make_uniform(qs, 'Intercept') \n```", "```py\nqs = np.linspace(0.0, 0.08, num=51)\nprior_slope = make_uniform(qs, 'Slope') \n```", "```py\n# Solution\n\njoint = make_joint(prior_inter, prior_slope)\njoint.head() \n```", "```py\n# Solution\n\njoint_pmf = Pmf(joint.stack())\njoint_pmf.head() \n```", "```py\n# Solution\n\nnum_legit = 9\nadhd1 = adhd.loc[0:num_legit-1]\nadhd2 = adhd.loc[num_legit:]\nadhd1 \n```", "```py\n# Solution\n\nadhd2 \n```", "```py\n# Solution\n\nfrom scipy.stats import binom\n\nlikelihood1 = joint_pmf.copy()\n\nxs = adhd1['x']\nks = adhd1['k']\nns = adhd1['n']\n\nfor slope, inter in joint_pmf.index:\n    ps = expit(inter + slope * xs)\n    likes = binom.pmf(ks, ns, ps)\n    likelihood1[slope, inter] = likes.prod()\n\nlikelihood1.sum() \n```", "```py\n3.5436858189129196e-14 \n```", "```py\n# Solution\n\n# This update uses the binomial survival function to compute\n# the probability that the number of cases *exceeds* `ks`.\n\nlikelihood2 = joint_pmf.copy()\n\nxs = adhd2['x']\nks = adhd2['k']\nns = adhd2['n']\n\nfor slope, inter in joint_pmf.index:\n    ps = expit(inter + slope * xs)\n    likes = binom.sf(ks, ns, ps)\n    likelihood2[slope, inter] = likes.prod()\n\nlikelihood2.sum() \n```", "```py\n1905.3511925068485 \n```", "```py\n# Solution\n\nposterior_pmf = joint_pmf * likelihood1\nposterior_pmf.normalize() \n```", "```py\n1.3624320718619453e-17 \n```", "```py\n# Solution\n\nposterior_pmf.max_prob() \n```", "```py\n(0.0448, -4.996) \n```", "```py\n# Solution\n\nposterior_pmf = joint_pmf * likelihood1 * likelihood2\nposterior_pmf.normalize() \n```", "```py\n1.3403142133315614e-17 \n```", "```py\n# Solution\n\nposterior_pmf.max_prob() \n```", "```py\n(0.0448, -4.996) \n```", "```py\n# Solution\n\njoint_posterior = posterior_pmf.unstack()\n\nplot_contour(joint_posterior)\ndecorate(title='Joint posterior distribution') \n```", "```py\n# Solution\n\nmarginal_inter = marginal(joint_posterior, 0)\nmarginal_slope = marginal(joint_posterior, 1)\n\nmarginal_inter.mean(), marginal_slope.mean() \n```", "```py\n(-4.999322906782624, 0.044607616771986124) \n```", "```py\n# Solution\n\nmarginal_inter.plot(color='C4')\ndecorate(xlabel='Intercept',\n         ylabel='PDF',\n         title='Posterior marginal distribution of intercept') \n```", "```py\n# Solution\n\nmarginal_slope.plot(color='C2')\n\ndecorate(xlabel='Slope',\n         ylabel='PDF',\n         title='Posterior marginal distribution of slope') \n```", "```py\n# Solution\n\nsample = posterior_pmf.choice(101)\nxs = adhd['x']\nps = np.empty((len(sample), len(xs)))\n\nfor i, (slope, inter) in enumerate(sample):\n    ps[i] = expit(inter + slope * xs)\n\nps.shape \n```", "```py\n(101, 12) \n```", "```py\n# Solution\n\nlow, median, high = np.percentile(ps, [2.5, 50, 97.5], axis=0)\nmedian \n```", "```py\narray([0.00663988, 0.00695303, 0.00728085, 0.00762401, 0.00798321,\n       0.00835919, 0.00875272, 0.00915734, 0.00955774, 0.00997548,\n       0.01043603, 0.01094356]) \n```", "```py\n# Solution\n\nplt.fill_between(xs, low*10000, high*10000, \n                 color='C1', alpha=0.2)\n\nplt.plot(xs, median*10000, label='model',\n         color='C1', alpha=0.5)\n\nplot_adhd(adhd) \n```"]