["```py\nimport networkx as nx\n\nG = nx.Graph()\nG.add_node('Alice')\nG.add_node('Bob', age=23)\nG.add_node('Carol', cat='mittens')\nlist(G.nodes()) \n```", "```py\n['Alice', 'Bob', 'Carol'] \n```", "```py\nG.add_edge('Alice', 'Bob')\nG.add_edge('Alice', 'Carol', type='enemy')\nlist(G.edges()) \n```", "```py\n[('Alice', 'Bob'), ('Alice', 'Carol')] \n```", "```py\ndef draw_graph(G):\n    nx.draw_circular(G, node_size=1500, with_labels=True) \n```", "```py\ndraw_graph(G) \n```", "```py\nG['Alice'] \n```", "```py\nAtlasView({'Bob': {}, 'Carol': {'type': 'enemy'}}) \n```", "```py\nfor neighbor in G['Alice']:\n    print(neighbor) \n```", "```py\nBob\nCarol \n```", "```py\nfor key, value in G['Alice'].items():\n    print(key, value) \n```", "```py\nBob {}\nCarol {'type': 'enemy'} \n```", "```py\nG['Alice']['Carol'] \n```", "```py\n{'type': 'enemy'} \n```", "```py\ndef has_edge(G, u, v):\n    return v in G[u] \n```", "```py\nhas_edge(G, 'Alice', 'Bob') \n```", "```py\nTrue \n```", "```py\nG.has_edge('Alice', 'Bob') \n```", "```py\nTrue \n```", "```py\ndef all_pairs(nodes):\n    for i, u in enumerate(nodes):\n        for j, v in enumerate(nodes):\n            if i < j:\n                yield u, v \n```", "```py\ndef make_complete_graph(n):\n    nodes = range(n)\n    G = nx.Graph()\n    G.add_nodes_from(nodes)\n    G.add_edges_from(all_pairs(nodes))\n    return G \n```", "```py\ncomplete = make_complete_graph(10) \n```", "```py\ndraw_graph(complete) \n```", "```py\nimport random\n\ndef flip(p):\n    return random.random() < p \n```", "```py\ndef random_pairs(nodes, p):\n    for edge in all_pairs(nodes):\n        if flip(p):\n            yield edge \n```", "```py\ndef make_random_graph(n, p):\n    nodes = range(n)\n    G = nx.Graph()\n    G.add_nodes_from(nodes)\n    G.add_edges_from(random_pairs(nodes, p))\n    return G \n```", "```py\nrandom_graph = make_random_graph(10, 0.3)\nlen(random_graph.edges()) \n```", "```py\n9 \n```", "```py\ndraw_graph(random_graph) \n```", "```py\ndef basic_dfs(G, start):\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        print(node)\n        stack.extend(G[node]) \n```", "```py\n# basic_dfs(random_graph, 0) \n```", "```py\nreachable_nodes(complete, 0) \n```", "```py\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} \n```", "```py\nreachable_nodes(random_graph, 0) \n```", "```py\n{0, 1, 3, 4, 5, 7, 9} \n```", "```py\ndef is_connected(G):\n    start = next(iter(G))\n    reachable = reachable_nodes(G, start)\n    return len(reachable) == len(G) \n```", "```py\nis_connected(complete) \n```", "```py\nTrue \n```", "```py\nrandom_graph = make_random_graph(10, 0.1)\nlen(random_graph.edges()) \n```", "```py\n4 \n```", "```py\nis_connected(random_graph) \n```", "```py\nFalse \n```", "```py\nrandom_graph = make_random_graph(10, 0.9)\nlen(random_graph.edges()) \n```", "```py\n40 \n```", "```py\nis_connected(random_graph) \n```", "```py\nTrue \n```", "```py\nimport numpy as np\n\ndef prob_connected(n, p, iters=100):\n    tf = [is_connected(make_random_graph(n, p))\n          for i in range(iters)]\n    return np.mean(tf) \n```", "```py\nn = 10\nprob_connected(n, 0.23, iters=10000) \n```", "```py\n0.3518 \n```", "```py\npstar = np.log(n) / n\npstar \n```", "```py\n0.23025850929940458 \n```", "```py\nps = np.logspace(-1.3, 0, 11)\nps \n```", "```py\narray([0.05011872, 0.0676083 , 0.09120108, 0.12302688, 0.16595869,\n       0.22387211, 0.30199517, 0.40738028, 0.54954087, 0.74131024,\n       1\\.        ]) \n```", "```py\nys = [prob_connected(n, p, 1000) for p in ps]\n\nfor p, y in zip(ps, ys):\n    print(p, y) \n```", "```py\n0.05011872336272722 0.0\n0.06760829753919818 0.001\n0.09120108393559097 0.003\n0.12302687708123815 0.028\n0.16595869074375605 0.128\n0.22387211385683395 0.319\n0.3019951720402016 0.679\n0.40738027780411273 0.927\n0.5495408738576245 0.995\n0.7413102413009173 1.0\n1.0 1.0 \n```", "```py\nimport matplotlib.pyplot as plt\n\nplt.axvline(pstar, color='gray')\nplt.plot(ps, ys, color='green')\nplt.xlabel('Prob of edge (p)')\nplt.ylabel('Prob connected')\nplt.xscale('log') \n```", "```py\ncomplete = make_complete_graph(100) \n```", "```py\n%timeit len(reachable_nodes(complete, 0)) \n```", "```py\n565 \u00b5s \u00b1 8.91 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) \n```", "```py\n%timeit len(reachable_nodes_precheck(complete, 0)) \n```", "```py\n611 \u00b5s \u00b1 47.9 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) \n```"]