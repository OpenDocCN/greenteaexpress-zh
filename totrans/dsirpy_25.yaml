- en: Breadth First Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/DSIRP/bfs.html](https://allendowney.github.io/DSIRP/bfs.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Click here to run this chapter on Colab](https://colab.research.google.com/github/AllenDowney/DSIRP/blob/main/notebooks/bfs.ipynb)'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous notebook, we constructed an Erdos-Renyi graph and wrote a version
    of depth-first search (DFS) that works for graphs.
  prefs: []
  type: TYPE_NORMAL
- en: When we did DFS in a tree, there was only one path from the root to any other
    node, so we never discovered the same node twice. In a graph, there might be multiple
    paths to the same node. To avoid discovering the same node over and over, we have
    to keep track of the nodes we’ve seen.
  prefs: []
  type: TYPE_NORMAL
- en: In this notebook, we’ll adapt the level-order traversal in the same way; the
    result is a breadth-first search (BFS). Then we’ll adapt BFS to implement Dijkstra’s
    algorithm, which computes the shortest path from a starting node to every other
    node (provided it is reachable).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll test these functions with a Watts-Strogatz graph, then replicate part
    of an experiment from a [well-known paper](https://github.com/AllenDowney/ThinkComplexity2/blob/master/papers/watts98collective.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Watts-Strogatz graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Watts-Strogatz (WS) graph is a random graph, like an Erdos-Renyi graph, but
    the construction process is different. A WS graph starts with a ring lattice and
    randomly “rewires” some of the edges.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX provides [a function that makes a WS graph](https://networkx.org/documentation/stable/reference/generated/networkx.generators.random_graphs.watts_strogatz_graph.html),
    so we can see what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example with `n=10` nodes, each connected to `k=2` neighbors, with
    probability `p=0` of rewiring each edge.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result is a ring where each node holds hands with its immediate neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/bfs_7_0.png](../Images/02628b594b42d544ccb2dc0e46921919.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Exercise:** Run this code again with different values of `k` and `p` to see
    what the effect is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: If `k` is odd, it gets “rounded down” to an even number.'
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the function from the previous notebook that implements depth-first search
    in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise:** Make a version of this function called `reachable_nodes_bfs`
    that does the same thing using breadth-first search.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use this example to test your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Fast BFS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NetworkX provides a simple, fast implementation of BFS, available from [the
    NetworkX repository on GitHub](https://github.com/networkx/networkx/blob/master/networkx/algorithms/components/connected.py).
    Here is a version I modified to return a set of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let’s compare this function to `reachable_nodes_bfs` and see which is faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Dijkstra’s algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During a breadth-first search, whenever we discover a new node, the path we
    took must be the shortest. That’s necessarily true because, if there had been
    a shorter path, we would have discovered the node sooner.
  prefs: []
  type: TYPE_NORMAL
- en: This insight is the basis of Dijkstra’s algorithm, which computes the shortest
    path from a give “source” node to all other (reachable) nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The general version of Dijkstra’s algorithm works on graphs where the edges
    have different lengths, like the distance between cities, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a simpler version where all edges have length `1`. This version
    is similar to BFS, with one change: instead of keeping a set of nodes that have
    already been seen, we keep a dictionary that maps from each discovered node to
    its distance from the source.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Write a version of `reachable_nodes_bfs` called `shortest_path_dijkstra`.
    It should take a graph and a source node as parameters and return a dictionary
    that maps from each reachable node to its distance from the source.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Start with a dictionary that maps from the source node to distance `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll test it on a ring lattice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/bfs_28_0.png](../Images/9e8445f8be9746ea2aa649995a307532.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise:** Starting with `plain_bfs` write a (possibly faster) implementation
    of Dijkstra’s algorithm that returns a dictionary that maps from each reachable
    node to its distance from a given source node.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the following example to test it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: And let’s see which version is faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can also compare it to the NetworkX function that does the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The WS Experiment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original purpose of the Watts-Strogatz graph is to explore the structure
    of social networks, particularly the “small world” phenomenon, also known as “six
    degrees of separation”.
  prefs: []
  type: TYPE_NORMAL
- en: 'The observation is that path lengths in social networks are shorter than you
    might expect: the distance between any two people on earth might be six connections
    (or less) on average.'
  prefs: []
  type: TYPE_NORMAL
- en: The random edges in a WS graph often connect people in parts of the graph that
    would otherwise be far apart. Even a small number of these “long links” can greatly
    reduce the average path length.
  prefs: []
  type: TYPE_NORMAL
- en: To replicate part of their original experiment, I’ll use `nx.average_shortest_path_length`,
    which takes a graph, uses the unweighted version of Dijkstra’s algorithm to compute
    the shortest path from each node to all of the others, and returns the average
    of the shortest path lengths.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’ll run this function for WS graphs with a range of values for `p`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what the result looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/bfs_46_0.png](../Images/856a843336cc914e90590941a316e471.png)'
  prefs: []
  type: TYPE_IMG
- en: With `p=0.01`, we’re only rewiring 1% of the edges, but the average path length
    is already down about as low as it will go.
  prefs: []
  type: TYPE_NORMAL
- en: '*Data Structures and Information Retrieval in Python*'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2021 Allen Downey
  prefs: []
  type: TYPE_NORMAL
- en: 'License: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
