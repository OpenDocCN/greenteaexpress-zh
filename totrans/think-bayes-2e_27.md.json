["```py\nimport pandas as pd\n\ndef bayes_table(hypos, prior, likelihood):\n  \"\"\"Make a table showing a Bayesian update.\"\"\"\n    table = pd.DataFrame(dict(prior=prior, likelihood=likelihood), index=hypos)\n    table['unnorm'] = table['prior'] * table['likelihood']\n    prob_data = table['unnorm'].sum()\n    table['posterior'] = table['unnorm'] / prob_data\n    return table \n```", "```py\nimport numpy as np\n\ndef expo_sf(t, lam):\n  \"\"\"Survival function of the exponential distribution.\"\"\"\n    return np.exp(-lam * t) \n```", "```py\nt = 0.9\nmu = 1.1\nlam = 1/mu\n\nexpo_sf(t, lam) \n```", "```py\n0.441233167759984 \n```", "```py\nhypos = ['Right way', 'Wrong way']\nprior = [1/2, 1/2] \n```", "```py\nlikelihood = [expo_sf(t, lam), 1] \n```", "```py\nbayes_table(hypos, prior, likelihood) \n```", "```py\nfrom sympy import symbols, exp\n\nt, lam, p, q, r = symbols('t lam p q r') \n```", "```py\nlikelihood = [exp(-lam * t), 1]\nlikelihood \n```", "```py\n[exp(-lam*t), 1] \n```", "```py\nprior = [p, q]\ntable = bayes_table(hypos, prior, likelihood)\ntable \n```", "```py\nexpr = table.loc['Right way', 'posterior']\nexpr.simplify() \n```", "```py\ndef logistic(p, lam, t):\n    q = 1-p\n    return p / (p + q * np.exp(lam * t)) \n```", "```py\nimport matplotlib.pyplot as plt\n\nts = np.linspace(0, 4)\nps = logistic(p=0.5, lam=1/mu, t=ts)\n\nplt.plot(ts, ps)\nplt.xlabel(\"How long you've been trying (seconds)\")\nplt.ylabel(\"Probability the orientation is right\"); \n```", "```py\nfrom sympy import Eq, solve\n\neqn = Eq(expr, r)\neqn \n```", "```py\nsolve(eqn, t)[0] \n```", "```py\ndef wait_time(p, lam, r):\n    q = 1-p\n    prior_odds = p / q\n    posterior_odds = r / (1-r)\n    return np.log(prior_odds / posterior_odds) / lam \n```", "```py\nrs = np.linspace(0.05, 0.5)\nts = wait_time(p=0.5, lam=1/mu, r=rs)\n\nplt.plot(rs, ts, color='C2')\nplt.xlabel(\"Probability the orientation is right\")\nplt.ylabel(\"How long to keep trying (seconds)\"); \n```", "```py\ndef simulate(correct, p, lam, r, flip, trace):\n    # figure out the maximum time we should try before flipping\n    wait = wait_time(p, lam, r)\n\n    # if we're on the correct side, see if we succeed before time's up\n    if correct:\n        t = np.random.exponential(1/lam)\n        if t < wait:\n            # if so, update and return the trace\n            return trace + [t]\n\n    # if time expired, add the wait time and flip time to the trace \n    # and make a recursive call to continue the simulation\n    return simulate(not correct, 1-r, lam, r, flip, trace + [wait, flip]) \n```", "```py\nsimulate(correct=True, p=0.5, lam=1/mu, r=0.2, flip=0.1, trace=[]) \n```", "```py\n[0.24846062544031747] \n```", "```py\nsimulate(correct=False, p=0.5, lam=1/mu, r=0.2, flip=0.1, trace=[]) \n```", "```py\n[1.5249237972318797, 0.1, 0.8563018209476607] \n```", "```py\ndef run_simulations(lam, r, flip, iters=20000, flag=None):\n    res = []\n    for i in range(iters):\n        correct = i%2 if flag is None else flag\n        trace = simulate(correct, 0.5, lam, r, flip, [])\n        res.append((len(trace), sum(trace)))\n\n    return np.transpose(res) \n```", "```py\nlengths, totals = run_simulations(lam=1/mu, r=0.25, flip=0.1)\ntotals.mean() \n```", "```py\n2.4265255008111306 \n```", "```py\nrs = np.linspace(0.15, 0.4, 21)\nrs \n```", "```py\narray([0.15  , 0.1625, 0.175 , 0.1875, 0.2   , 0.2125, 0.225 , 0.2375,\n       0.25  , 0.2625, 0.275 , 0.2875, 0.3   , 0.3125, 0.325 , 0.3375,\n       0.35  , 0.3625, 0.375 , 0.3875, 0.4   ]) \n```", "```py\nnp.random.seed(17)\n\nres = []\nfor r in rs:\n    lengths, totals = run_simulations(lam=1/mu, r=r, flip=0.1)\n    res.append((r, totals.mean())) \n```", "```py\nfrom statsmodels.nonparametric.smoothers_lowess import lowess\n\ndef make_lowess(series):\n  \"\"\"Use LOWESS to compute a smooth line.\n\n series: pd.Series\n\n returns: pd.Series\n \"\"\"\n    endog = series.values\n    exog = series.index.values\n\n    smooth = lowess(endog, exog)\n    index, data = np.transpose(smooth)\n\n    return pd.Series(data, index=index) \n```", "```py\ndef plot_series_lowess(series, color):\n  \"\"\"Plots a series of data points and a smooth line.\n\n series: pd.Series\n color: string or tuple\n \"\"\"\n    series.plot(lw=0, marker='o', color=color, alpha=0.5)\n    smooth = make_lowess(series)\n    smooth.plot(label='_', color=color) \n```", "```py\nrs, ts = np.transpose(res)\nseries = pd.Series(ts, rs)\n\nplot_series_lowess(series, 'C1')\n\nplt.xlabel(\"Threshold probability where you flip (r)\")\nplt.ylabel(\"Average total duration (seconds)\"); \n```", "```py\nr_opt = 0.3\nwait_time(p=0.5, lam=1/mu, r=r_opt) \n```", "```py\n0.9320276464259238 \n```", "```py\nwait_time(p=1-r_opt, lam=1/mu, r=r_opt) \n```", "```py\n1.864055292851848 \n```", "```py\nlengths1, totals1 = run_simulations(lam=1/mu, r=r_opt, flip=0.1, flag=True)\nlengths2, totals2 = run_simulations(lam=1/mu, r=r_opt, flip=0.1, flag=False) \n```", "```py\ntry:\n    import empiricaldist\nexcept ImportError:\n    !pip  install  empiricaldist \n```", "```py\nfrom empiricaldist import Cdf\n\nCdf.from_seq(totals1).plot(lw=2, label='Right the first time')\nCdf.from_seq(totals2).plot(lw=2, label='Wrong the first time')\n\nplt.xlabel('Total time to connect (seconds)')\nplt.ylabel('CDF')\nplt.title('Distribution of total time to connect')\nplt.legend(); \n```", "```py\ntotals1.mean(), totals2.mean() \n```", "```py\n(2.2006236558767154, 2.616228241925388) \n```", "```py\nnp.percentile(totals1, 90), np.percentile(totals2, 90) \n```", "```py\n(4.601034595944718, 5.636579992175272) \n```", "```py\nnp.append(totals1, totals2).mean() \n```", "```py\n2.4084259489010518 \n```", "```py\nfrom empiricaldist import Pmf\n\nflips1 = (lengths1-1) // 2\npmf1 = Pmf.from_seq(flips1) / 2\npmf1.bar(alpha=0.7, label='Right the first time')\n\nflips2 = (lengths2-1) // 2\npmf2 = Pmf.from_seq(flips2) / 2\npmf2.bar(alpha=0.7, label='Right the second time')\n\nplt.xlabel('How many times you have to flip')\nplt.ylabel('PMF')\nplt.title('Distribution of number of flips')\nplt.legend(); \n```", "```py\nlengths = np.append(lengths1, lengths2)\nflips = (lengths-1) // 2\nPmf.from_seq(flips).head(5) \n```"]