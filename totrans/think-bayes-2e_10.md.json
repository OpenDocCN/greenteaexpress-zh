["```py\n# Get utils.py\n\nfrom os.path import basename, exists\n\ndef download(url):\n    filename = basename(url)\n    if not exists(filename):\n        from urllib.request import urlretrieve\n        local, _ = urlretrieve(url, filename)\n        print('Downloaded ' + local)\n\ndownload('https://github.com/AllenDowney/ThinkBayes2/raw/master/soln/utils.py') \n```", "```py\nimport numpy as np\nfrom empiricaldist import Pmf\n\nhypos = np.linspace(0, 1, 101)\npmf = Pmf(1, hypos)\ndata = 140, 250 \n```", "```py\nfrom scipy.stats import binom\n\ndef update_binomial(pmf, data):\n  \"\"\"Update pmf using the binomial distribution.\"\"\"\n    k, n = data\n    xs = pmf.qs\n    likelihood = binom.pmf(k, n, xs)\n    pmf *= likelihood\n    pmf.normalize() \n```", "```py\nupdate_binomial(pmf, data) \n```", "```py\ncumulative = pmf.cumsum() \n```", "```py\nfrom utils import decorate\n\ndef decorate_euro(title):\n    decorate(xlabel='Proportion of heads (x)',\n             ylabel='Probability',\n             title=title) \n```", "```py\ncumulative.plot(label='CDF')\npmf.plot(label='PMF')\ndecorate_euro(title='Posterior distribution for the Euro problem') \n```", "```py\ncumulative[0.61] \n```", "```py\n0.9638303193984255 \n```", "```py\nfrom scipy.interpolate import interp1d\n\nps = cumulative.values\nqs = cumulative.index\n\ninterp = interp1d(ps, qs)\ninterp(0.96) \n```", "```py\narray(0.60890171) \n```", "```py\ncdf = pmf.make_cdf() \n```", "```py\ncdf[0.61] \n```", "```py\n0.9638303193984255 \n```", "```py\ntry:\n    cdf[0.615]\nexcept KeyError as e:\n    print(repr(e)) \n```", "```py\nKeyError(0.615) \n```", "```py\ncdf(0.615) \n```", "```py\narray(0.96383032) \n```", "```py\ncdf.quantile(0.9638303) \n```", "```py\narray(0.61) \n```", "```py\ncdf.credible_interval(0.9) \n```", "```py\narray([0.51, 0.61]) \n```", "```py\npmf = cdf.make_pmf() \n```", "```py\nfrom utils import make_die\n\ndie = make_die(6)\ndice = [die] * 3 \n```", "```py\nfrom utils import add_dist_seq\n\npmf_3d6 = add_dist_seq(dice) \n```", "```py\ndef decorate_dice(title=''):\n    decorate(xlabel='Outcome',\n             ylabel='PMF',\n             title=title) \n```", "```py\npmf_3d6.plot()\ndecorate_dice('Distribution of attributes') \n```", "```py\nn = 10000\na = np.random.randint(1, 7, size=(n, 4)) \n```", "```py\na.sort(axis=1) \n```", "```py\nt = a[:, 1:].sum(axis=1) \n```", "```py\npmf_best3 = Pmf.from_seq(t) \n```", "```py\npmf_3d6.plot(label='sum of 3 dice')\npmf_best3.plot(label='best 3 of 4', ls='--')\n\ndecorate_dice('Distribution of attributes') \n```", "```py\ncdf_best3 = pmf_best3.make_cdf() \n```", "```py\ncdf_best3**6 \n```", "```py\n3     4.665600e-20\n4     5.948233e-16\n5     3.297304e-12\n6     4.139767e-10\n7     3.084098e-08\n8     1.000000e-06\n9     2.248307e-05\n10    3.110606e-04\n11    2.935667e-03\n12    1.706486e-02\n13    6.693521e-02\n14    1.998047e-01\n15    4.212166e-01\n16    6.859162e-01\n17    9.049950e-01\n18    1.000000e+00\ndtype: float64 \n```", "```py\nfrom empiricaldist import Cdf\n\ncdf_max6 = Cdf(cdf_best3**6) \n```", "```py\npmf_max6 = cdf_max6.make_pmf() \n```", "```py\npmf_max6.plot(label='max of 6 attributes')\n\ndecorate_dice('Distribution of attributes') \n```", "```py\nimport matplotlib.pyplot as plt\n\ncdf_3d6 = pmf_3d6.make_cdf()\ncdf_3d6.plot(label='sum of 3 dice')\n\ncdf_best3 = pmf_best3.make_cdf()\ncdf_best3.plot(label='best 3 of 4 dice', ls='--')\n\ncdf_max6.plot(label='max of 6 attributes', ls=':')\n\ndecorate_dice('Distribution of attributes')\nplt.ylabel('CDF'); \n```", "```py\ncdf_max_dist6 = cdf_best3.max_dist(6) \n```", "```py\nprob_gt = 1 - cdf_best3 \n```", "```py\nprob_gt6 = prob_gt**6 \n```", "```py\nprob_le6 = 1 - prob_gt6 \n```", "```py\ncdf_min6 = Cdf(prob_le6) \n```", "```py\ncdf_min6.plot(color='C4', label='minimum of 6')\ncdf_max6.plot(color='C2', label='maximum of 6', ls=':')\ndecorate_dice('Minimum and maximum of six attributes')\nplt.ylabel('CDF'); \n```", "```py\ncdf_min_dist6 = cdf_best3.min_dist(6) \n```", "```py\nnp.allclose(cdf_min_dist6, cdf_min6) \n```", "```py\nTrue \n```", "```py\nd4 = make_die(4)\nd6 = make_die(6) \n```", "```py\nprob_1 = (d4(1) + d6(1)) / 2\nprob_1 \n```", "```py\n0.20833333333333331 \n```", "```py\nprob_6 = (d4(6) + d6(6)) / 2\nprob_6 \n```", "```py\n0.08333333333333333 \n```", "```py\nmix1 = (d4 + d6) / 2 \n```", "```py\nmix1.bar(alpha=0.7)\ndecorate_dice('Mixture of one 4-sided and one 6-sided die') \n```", "```py\nmix2 = (d4 + 2*d6) / 3 \n```", "```py\nmix2.bar(alpha=0.7)\ndecorate_dice('Mixture of one 4-sided and two 6-sided die') \n```", "```py\ntotal_damage = Pmf.add_dist(mix1, mix2) \n```", "```py\ntotal_damage.bar(alpha=0.7)\ndecorate_dice('Total damage inflicted by both parties') \n```", "```py\nhypos = [4,6,8]\ncounts = [1,2,3]\npmf_dice = Pmf(counts, hypos)\npmf_dice.normalize()\npmf_dice \n```", "```py\ndice = [make_die(sides) for sides in hypos] \n```", "```py\nimport pandas as pd\n\npd.DataFrame(dice) \n```", "```py\ndf = pd.DataFrame(dice).fillna(0).transpose() \n```", "```py\ndf \n```", "```py\ndf *= pmf_dice.ps \n```", "```py\ndf \n```", "```py\ndf.sum(axis=1) \n```", "```py\n1    0.159722\n2    0.159722\n3    0.159722\n4    0.159722\n5    0.118056\n6    0.118056\n7    0.062500\n8    0.062500\ndtype: float64 \n```", "```py\ndef make_mixture(pmf, pmf_seq):\n  \"\"\"Make a mixture of distributions.\"\"\"\n    df = pd.DataFrame(pmf_seq).fillna(0).transpose()\n    df *= np.array(pmf)\n    total = df.sum(axis=1)\n    return Pmf(total) \n```", "```py\nmix = make_mixture(pmf_dice, dice) \n```", "```py\nmix.bar(label='mixture', alpha=0.6)\ndecorate_dice('Distribution of damage with three different weapons') \n```", "```py\nstandard = [15,14,13,12,10,8]\ncdf_standard = Cdf.from_seq(standard) \n```", "```py\ncdf_best3.plot(label='best 3 of 4', color='C1', ls='--')\ncdf_standard.step(label='standard set', color='C7')\n\ndecorate_dice('Distribution of attributes')\nplt.ylabel('CDF'); \n```", "```py\n# Solution\n\n# Here are the means\ncdf_best3.mean(), cdf_standard.mean() \n```", "```py\n(12.296699999999998, 12.0) \n```", "```py\n# Solution\n\n# And the standard deviations\ncdf_best3.std(), cdf_standard.std() \n```", "```py\n(2.8381101299984817, 2.3804761428476167) \n```", "```py\n# Solution\n\n# Here's the probability that a single attribute is less than 8\ncdf_best3.lt_dist(8) \n```", "```py\n0.055999999999999994 \n```", "```py\n# Solution\n\n# And the probability that a single attribute is greater than 15\ncdf_best3.gt_dist(15) \n```", "```py\n0.13419999999999999 \n```", "```py\n# Solution\n\n# Here are two ways to compute the probability that at\n# least one attribute is less than 8\ncdf_min6.lt_dist(8), 1 - (1-cdf_best3.lt_dist(8))**6 \n```", "```py\n(0.2923280761096768, 0.2923280761096768) \n```", "```py\n# Solution\n\n# And two ways to compute the probability that at least\n# one attribute is greater than 15\ncdf_max6.gt_dist(15), 1 - (1-cdf_best3.gt_dist(15))**6 \n```", "```py\n(0.5787833897023915, 0.5787833897023917) \n```", "```py\n# Solution\n\n# Here's what we believe about the dice after seeing the data\n\nhypos = [6, 8, 10]\nprior = Pmf(1, hypos)\nlikelihood = 1/prior.qs\nposterior = prior * likelihood\nposterior.normalize()\nposterior \n```", "```py\n# Solution\n\n# Here's a sequence that represents the three dice\n\nd6 = make_die(6)\nd8 = make_die(8)\nd10 = make_die(10)\n\ndice = d6, d8, d10 \n```", "```py\n# Solution\n\n# And here's a mixture of the three dice, weighting\n# each one with the probability from the posterior distribution\n\nmix3 = make_mixture(posterior, dice)\nmix3.bar() \n```", "```py\n# Solution\n\n# From the mixture, we can pull out the probability of\n# rolling a 6.\n\nmix3[6] \n```", "```py\n0.13634751773049647 \n```", "```py\nmean = 950\nstd = 50\n\nnp.random.seed(17)\nsample = np.random.normal(mean, std, size=365) \n```", "```py\n# Solution\n\n# Here's the mean of the maximum of `n` loaves,\n# for a range of values of `n`\n\ncdf = Cdf.from_seq(sample)\n\nfor n in range(2, 6):\n    cdf_max = cdf.max_dist(n)\n    print(n, cdf_max.mean()) \n```", "```py\n2 978.4666876067706\n3 992.7589004318227\n4 1002.0372868686195\n5 1008.8226939493089 \n```", "```py\n# Solution\n\n# It looks like hefting 4 loaves is enough to get the mean over 1000,\n# so the story is not entirely implausible.\n\n# Here's what the distribution of the maximum looks like, compared\n# to the actual distribution of weights.\n\ncdf.plot(label='one loaf')\ncdf.max_dist(4).plot(label='maximum of four loaves')\n\ndecorate(xlabel='Weight in grams',\n         ylabel='CDF') \n```"]