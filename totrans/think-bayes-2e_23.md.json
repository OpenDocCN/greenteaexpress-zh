["```py\nimport numpy as np\n\ndef calc_volume(diameter):\n  \"\"\"Converts a diameter to a volume.\"\"\"\n    factor = 4 * np.pi / 3\n    return factor * (diameter/2.0)**3 \n```", "```py\nd1 = 1\nv1 = calc_volume(d1)\nv1 \n```", "```py\n0.5235987755982988 \n```", "```py\nmedian_doubling_time = 811\nrdt = 365 / median_doubling_time\nrdt \n```", "```py\n0.45006165228113443 \n```", "```py\ninterval = 9.0\ndoublings = interval * rdt\ndoublings \n```", "```py\n4.05055487053021 \n```", "```py\nv2 = v1 * 2**doublings\nv2 \n```", "```py\n8.676351488087187 \n```", "```py\ndef calc_diameter(volume):\n  \"\"\"Converts a volume to a diameter.\"\"\"\n    factor = 3 / np.pi / 4\n    return 2 * (factor * volume)**(1/3) \n```", "```py\nd2 = calc_diameter(v2)\nd2 \n```", "```py\n2.5494480788327483 \n```", "```py\n# Data from the scatter plot in Figure 4\n\nrdts = [5.089,  3.572,  3.242,  2.642,  1.982,  1.847,  1.908,  1.798,\n        1.798,  1.761,  2.703, -0.416,  0.024,  0.869,  0.746,  0.257,\n        0.269,  0.086,  0.086,  1.321,  1.052,  1.076,  0.758,  0.587,\n        0.367,  0.416,  0.073,  0.538,  0.281,  0.122, -0.869, -1.431,\n        0.012,  0.037, -0.135,  0.122,  0.208,  0.245,  0.404,  0.648,\n        0.673,  0.673,  0.563,  0.391,  0.049,  0.538,  0.514,  0.404,\n        0.404,  0.33,  -0.061,  0.538,  0.306]\n\nrdt_sample = np.array(rdts)\nlen(rdt_sample) \n```", "```py\n53 \n```", "```py\nfrom utils import kde_from_sample\n\nqs = np.linspace(-2, 6, num=201)\npmf_rdt = kde_from_sample(rdt_sample, qs) \n```", "```py\nfrom utils import decorate\n\npmf_rdt.plot(label='rdts')\n\ndecorate(xlabel='Reciprocal doubling time (RDT)',\n         ylabel='PDF',\n         title='Distribution of growth rates') \n```", "```py\ninterval = 245 / 365      # year\nmin_diameter = 0.3        # cm\nmax_diameter = 20         # cm \n```", "```py\nv0 = calc_volume(min_diameter)\nvmax = calc_volume(max_diameter)\nv0, vmax \n```", "```py\n(0.014137166941154066, 4188.790204786391) \n```", "```py\nimport pandas as pd\n\ndef simulate_growth(pmf_rdt):\n  \"\"\"Simulate the growth of a tumor.\"\"\"\n    age = 0\n    volume = v0\n    res = []\n\n    while True:\n        res.append((age, volume))\n        if volume > vmax:\n            break\n\n        rdt = pmf_rdt.choice()\n        age += interval \n        doublings = rdt * interval\n        volume *= 2**doublings\n\n    columns = ['age', 'volume']\n    sim = pd.DataFrame(res, columns=columns)\n    sim['diameter'] = calc_diameter(sim['volume'])\n    return sim \n```", "```py\nsim = simulate_growth(pmf_rdt) \n```", "```py\nsim.head(3) \n```", "```py\nsim.tail(3) \n```", "```py\nsims = [simulate_growth(pmf_rdt) for _ in range(101)] \n```", "```py\nimport matplotlib.pyplot as plt\n\ndiameters = [4, 8, 16]\nfor diameter in diameters:\n    plt.axhline(diameter,\n                color='C5', linewidth=2, ls=':')\n\nfor sim in sims:\n    plt.plot(sim['age'], sim['diameter'],\n             color='C1', linewidth=0.5, alpha=0.5)\n\ndecorate(xlabel='Tumor age (years)',\n         ylabel='Diameter (cm, log scale)',\n         ylim=[0.2, 20],\n         yscale='log')\n\nyticks = [0.2, 0.5, 1, 2, 5, 10, 20]\nplt.yticks(yticks, yticks); \n```", "```py\nfrom scipy.interpolate import interp1d\n\ndef interpolate_ages(sims, diameter):\n  \"\"\"Estimate the age when each tumor reached a given size.\"\"\"\n    ages = []\n    for sim in sims:\n        interp = interp1d(sim['diameter'], sim['age'])\n        age = interp(diameter)\n        ages.append(float(age))\n    return ages \n```", "```py\nfrom empiricaldist import Cdf\n\nages = interpolate_ages(sims, 15)\ncdf = Cdf.from_seq(ages)\nprint(cdf.median(), cdf.credible_interval(0.9)) \n```", "```py\n22.31854530374061 [13.47056554 34.49632276] \n```", "```py\n1 - cdf(9.0) \n```", "```py\n0.9900990099009901 \n```", "```py\nfor diameter in diameters:\n    ages = interpolate_ages(sims, diameter)\n    cdf = Cdf.from_seq(ages)\n    cdf.plot(label=f'{diameter} cm')\n\ndecorate(xlabel='Tumor age (years)',\n         ylabel='CDF') \n```", "```py\ntotal_squares = 25\nsquares_counted = 5\nyeast_counted = 49 \n```", "```py\nimport pymc3 as pm\nbillion = 1e9\n\nwith pm.Model() as model:\n    yeast_conc = pm.Normal(\"yeast conc\", \n                           mu=2 * billion, sd=0.4 * billion)\n\n    shaker1_vol = pm.Normal(\"shaker1 vol\", \n                               mu=9.0, sd=0.05)\n    shaker2_vol = pm.Normal(\"shaker2 vol\", \n                               mu=9.0, sd=0.05)\n    shaker3_vol = pm.Normal(\"shaker3 vol\", \n                               mu=9.0, sd=0.05) \n```", "```py\nwith model:\n    yeast_slurry_vol = pm.Normal(\"yeast slurry vol\",\n                                    mu=1.0, sd=0.01)\n    shaker1_to_shaker2_vol = pm.Normal(\"shaker1 to shaker2\",\n                                    mu=1.0, sd=0.01)\n    shaker2_to_shaker3_vol = pm.Normal(\"shaker2 to shaker3\",\n                                    mu=1.0, sd=0.01) \n```", "```py\nwith model:\n    dilution_shaker1 = (yeast_slurry_vol / \n                        (yeast_slurry_vol + shaker1_vol))\n    dilution_shaker2 = (shaker1_to_shaker2_vol / \n                        (shaker1_to_shaker2_vol + shaker2_vol))\n    dilution_shaker3 = (shaker2_to_shaker3_vol / \n                        (shaker2_to_shaker3_vol + shaker3_vol))\n\n    final_dilution = (dilution_shaker1 * \n                      dilution_shaker2 * \n                      dilution_shaker3) \n```", "```py\nwith model:\n    chamber_vol = pm.Gamma(\"chamber_vol\", \n                           mu=0.0001, sd=0.0001 / 20) \n```", "```py\nwith model:\n    yeast_in_chamber = pm.Poisson(\"yeast in chamber\", \n        mu=yeast_conc * final_dilution * chamber_vol) \n```", "```py\nwith model:\n    count = pm.Binomial(\"count\", \n                        n=yeast_in_chamber, \n                        p=squares_counted/total_squares,\n                        observed=yeast_counted) \n```", "```py\noptions = dict(return_inferencedata=False)\n\nwith model:\n    trace = pm.sample(1000, **options) \n```", "```py\nMultiprocess sampling (2 chains in 2 jobs)\nCompoundStep\n>NUTS: [chamber_vol, shaker2 to shaker3, shaker1 to shaker2, yeast slurry vol, shaker3 vol, shaker2 vol, shaker1 vol, yeast conc]\n>Metropolis: [yeast in chamber] \n```", "```py\nSampling 2 chains for 1_000 tune and 1_000 draw iterations (2_000 + 2_000 draws total) took 4 seconds.\nThe estimated number of effective samples is smaller than 200 for some parameters. \n```", "```py\nposterior_sample = trace['yeast conc'] / billion\ncdf_pymc = Cdf.from_seq(posterior_sample)\nprint(cdf_pymc.mean(), cdf_pymc.credible_interval(0.9)) \n```", "```py\n2.2712488367301873 [1.8531491 2.7017654] \n```", "```py\nwith model:\n    prior_sample = pm.sample_prior_predictive(10000) \n```", "```py\ncount = prior_sample['count']\nprint(count.mean()) \n```", "```py\n40.1144 \n```", "```py\nmask = (count == 49)\nmask.sum() \n```", "```py\n221 \n```", "```py\nposterior_sample2 = prior_sample['yeast conc'][mask] / billion \n```", "```py\ncdf_abc = Cdf.from_seq(posterior_sample2)\nprint(cdf_abc.mean(), cdf_abc.credible_interval(0.9)) \n```", "```py\n2.275872303142668 [1.87509925 2.72428803] \n```", "```py\ncdf_pymc.plot(label='MCMC', ls=':')\ncdf_abc.plot(label='ABC')\n\ndecorate(xlabel='Yeast concentration (cells/mL)',\n         ylabel='CDF',\n         title='Posterior distribution',\n         xlim=(1.4, 3.4)) \n```", "```py\nn = prior_sample['yeast in chamber']\nn.shape \n```", "```py\n(10000,) \n```", "```py\np = squares_counted/total_squares\np \n```", "```py\n0.2 \n```", "```py\nfrom scipy.stats import binom\n\nlikelihood = binom(n, p).pmf(yeast_counted).flatten() \n```", "```py\nlikelihood.shape \n```", "```py\n(10000,) \n```", "```py\nplt.plot(n*p, likelihood, '.', alpha=0.03, color='C2')\n\ndecorate(xlabel='Expected count (number of cells)',\n         ylabel='Likelihood') \n```", "```py\nqs = prior_sample['yeast conc'] / billion\nps = likelihood\nposterior_pmf = Pmf(ps, qs) \n```", "```py\nposterior_pmf.sort_index(inplace=True)\nposterior_pmf.normalize()\n\nprint(posterior_pmf.mean(), posterior_pmf.credible_interval(0.9)) \n```", "```py\n2.2723483584950497 [1.85449376 2.70563828] \n```", "```py\ncdf_pymc.plot(label='MCMC', ls=':')\n#cdf_abc.plot(label='ABC')\nposterior_pmf.make_cdf().plot(label='ABC2')\n\ndecorate(xlabel='Yeast concentration (cells/mL)',\n         ylabel='CDF',\n         title='Posterior distribution',\n         xlim=(1.4, 3.4)) \n```", "```py\n# Solution\n\nn_pairs = 9\nn_odds = 5\n\nsocks = np.append(np.arange(n_pairs), \n                  np.arange(n_pairs + n_odds))\n\nprint(socks) \n```", "```py\n[ 0  1  2  3  4  5  6  7  8  0  1  2  3  4  5  6  7  8  9 10 11 12 13] \n```", "```py\n# Solution\n\npicked_socks = np.random.choice(socks, size=11, replace=False)\npicked_socks \n```", "```py\narray([ 6,  5,  8,  7,  1,  0,  8,  5, 10, 12,  6]) \n```", "```py\n# Solution\n\nvalues, counts = np.unique(picked_socks, return_counts=True)\nvalues \n```", "```py\narray([ 0,  1,  5,  6,  7,  8, 10, 12]) \n```", "```py\n# Solution\n\ncounts \n```", "```py\narray([1, 1, 2, 2, 1, 2, 1, 1]) \n```", "```py\n# Solution\n\nsolo = np.sum(counts==1)\npairs = np.sum(counts==2)\n\nsolo, pairs \n```", "```py\n(5, 3) \n```", "```py\n# Solution\n\ndef pick_socks(n_pairs, n_odds, n_pick):\n    socks = np.append(np.arange(n_pairs), \n                      np.arange(n_pairs + n_odds))\n\n    picked_socks = np.random.choice(socks, \n                                    size=n_pick, \n                                    replace=False)\n\n    values, counts = np.unique(picked_socks, \n                               return_counts=True)\n    pairs = np.sum(counts==2)\n    odds = np.sum(counts==1)\n    return pairs, odds \n```", "```py\n# Solution\n\npick_socks(n_pairs, n_odds, 11) \n```", "```py\n(2, 7) \n```", "```py\n# Solution\n\ndata = (0, 11)\nres = []\nfor i in range(10000):\n    n_socks = prior_n_socks.rvs()\n    if n_socks < 11:\n        continue\n    prop_pairs = prior_prop_pair.rvs()\n    n_pairs = np.round(n_socks//2 * prop_pairs)\n    n_odds = n_socks - n_pairs*2\n    result = pick_socks(n_pairs, n_odds, 11)\n    if result == data:\n        res.append((n_socks, n_pairs, n_odds))\n\nlen(res) \n```", "```py\n1156 \n```", "```py\n# Solution\n\ncolumns = ['n_socks', 'n_pairs', 'n_odds']\nresults = pd.DataFrame(res, columns=columns)\nresults.head() \n```", "```py\n# Solution\n\nqs = np.arange(15, 100)\nposterior_n_socks = Pmf.from_seq(results['n_socks'])\nprint(posterior_n_socks.median(),\n      posterior_n_socks.credible_interval(0.9)) \n```", "```py\n44.0 [27\\. 74.] \n```", "```py\n# Solution\n\nposterior_n_socks.plot(label='posterior', drawstyle='steps')\n\ndecorate(xlabel='Number of socks',\n         ylabel='PMF') \n```"]