["```py\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nnp.random.seed(0) \n```", "```py\ntry:\n    import empiricaldist\nexcept ImportError:\n    !pip install empiricaldist \n```", "```py\nfrom scipy.stats import norm\n\ndist = norm(2, 0.2)\nlogs = dist.rvs(200)\nsample = np.exp(logs) \n```", "```py\nmu, sigma = sample.mean(), sample.std()\n\nlow, high = mu - 3.5*sigma, mu + 3.5*sigma\nxs = np.linspace(low, high)\nys = norm.cdf(xs, mu, sigma) \n```", "```py\nfrom empiricaldist import Cdf\n\nplt.plot(xs, ys, color='gray', alpha=0.4)\nCdf.from_seq(sample).plot()\nplt.xlabel('Quantity')\nplt.ylabel('CDF'); \n```", "```py\nfrom scipy.stats import anderson\n\nstatistic, critical_values, significance_level = anderson(sample)\nstatistic \n```", "```py\n1.7262363980891564 \n```", "```py\nsignificance_level \n```", "```py\narray([15\\. , 10\\. ,  5\\. ,  2.5,  1\\. ]) \n```", "```py\ncritical_values[2] \n```", "```py\n0.772 \n```", "```py\ndef anderson_test(sample):\n    statistic, critical_values, _ = anderson(sample)\n    return statistic > critical_values[2] \n```", "```py\nanderson_test(sample) \n```", "```py\nTrue \n```", "```py\ndef sample_and_test(dist, n):\n    logs = dist.rvs(n)\n    sample = np.exp(logs)\n    return anderson_test(sample) \n```", "```py\nn = 10\nsteps = norm(1.04, 0.01).rvs(1000)\nres = []\n\nfor step in steps:\n    result = sample_and_test(dist, int(n))\n    res.append((result, n))\n    if result:\n        n /= step\n    else:\n        n *= step \n```", "```py\ndata = pd.DataFrame(res, columns=['y', 'x'])\ndata['y'] = data['y'].astype(int)\ndata.head() \n```", "```py\nimport statsmodels.formula.api as smf\n\nresults = smf.logit('y ~ x', data=data).fit(disp=False)\nresults.params \n```", "```py\nIntercept   -1.684106\nx            0.014555\ndtype: float64 \n```", "```py\nfrom scipy.special import expit\n\nb, a = results.params\nns = np.logspace(1, 3)\nps = expit(a * ns + b)\n\nplt.plot(ns, ps)\nplt.xlabel('Sample size')\nplt.ylabel('Probability of rejection')\nplt.xscale('log') \n```", "```py\nfrom scipy.special import logit\n\nb, a = results.params\nn = (logit(0.5) - b) / a - b\nn \n```", "```py\n117.39253624525765 \n```", "```py\noutcomes = [sample_and_test(dist, int(n)) for i in range(1000)]\nnp.mean(outcomes) \n```", "```py\n0.483 \n```"]