- en: DataFrames and Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ElementsOfDataScience/07_dataframes.html](https://allendowney.github.io/ElementsOfDataScience/07_dataframes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Click here to run this notebook on Colab](https://colab.research.google.com/github/AllenDowney/ElementsOfDataScience/blob/master/07_dataframes.ipynb)
    or [click here to download it](https://github.com/AllenDowney/ElementsOfDataScience/raw/master/07_dataframes.ipynb).'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces Pandas, a Python library that provides functions for
    reading and writing data files, exploring and analyzing data, and generating visualizations.
    And it provides two new types for working with data, `DataFrame` and `Series`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use these tools to answer a data question: what is the average birth
    weight of babies in the United States? This example will demonstrate important
    steps in almost any data science project:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying data that can answer a question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtaining the data and loading it in Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking the data and dealing with errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting relevant subsets from the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using histograms to visualize a distribution of values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using summary statistics to describe the data in a way that best answers the
    question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Considering possible sources of error and limitations in our conclusions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by getting the data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll use data from the National Survey of Family Growth (NSFG), which is available
    from the National Center for Health Statistics at [https://www.cdc.gov/nchs/nsfg/index.htm](https://www.cdc.gov/nchs/nsfg/index.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the data, you have to agree to the Data User’s Agreement at [https://www.cdc.gov/nchs/data_access/ftp_dua.htm](https://www.cdc.gov/nchs/data_access/ftp_dua.htm).
    You should read those terms carefully, but let me draw your attention to what
    I think is the most important one:'
  prefs: []
  type: TYPE_NORMAL
- en: Make no attempt to learn the identity of any person or establishment included
    in these data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: NSFG respondents provide honest answers to questions of the most personal nature
    with the expectation that their identities will not be revealed. As ethical data
    scientists, we should respect their privacy and adhere to the terms of use.
  prefs: []
  type: TYPE_NORMAL
- en: Respondents to the NSFG provide general information about themselves, which
    is stored in the respondent file, and information about each time they have been
    pregnant, which is stored in the pregnancy file.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with the pregnancy file, which contains one row for each pregnancy
    and one column for each of the 248 variables. Each variable represents responses
    to a question on the NSFG questionnaire.
  prefs: []
  type: TYPE_NORMAL
- en: The data is stored in a fixed-width format, which means that every row is the
    same length and each variable spans a fixed range of characters (see [https://www.ibm.com/docs/en/baw/19.x?topic=formats-fixed-width-format](https://www.ibm.com/docs/en/baw/19.x?topic=formats-fixed-width-format)).
    For example, the first six characters in each row represent a variable called
    `CASEID`, which is a unique identifier for each respondent; the next two characters
    represent `PREGORDR`, which indicates whether a pregnancy is the respondent’s
    first, second, etc.
  prefs: []
  type: TYPE_NORMAL
- en: To read this data, we need a **data dictionary**, which specifies the names
    of the variables and the range of characters where each variable appears. The
    data and the data dictionary are available in separate files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Pandas can read data in most common formats, including CSV, Excel, and fixed-width
    format, but it cannot read the data dictionary, which is in Stata format. For
    that, we’ll use a Python library called `statadict`.
  prefs: []
  type: TYPE_NORMAL
- en: From `statadict`, we’ll import `parse_stata_dict`, which reads the data dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result is an object that contains
  prefs: []
  type: TYPE_NORMAL
- en: '`names`, which is a list of variable names, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colspecs`, which is a list of tuples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each tuple in `colspecs` specifies the first and last column where a variable
    appears.
  prefs: []
  type: TYPE_NORMAL
- en: These values are exactly the arguments we need to use `read_fwf`, which is the
    Pandas function that reads a file in fixed-width format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result from `read_fwf()` is a `DataFrame`, which is the primary type Pandas
    uses to store data. `DataFrame` has a method called `head()` that shows the first
    5 rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|  | CASEID | PREGORDR | HOWPREG_N | HOWPREG_P | MOSCURRP | NOWPRGDK | PREGEND1
    | PREGEND2 | HOWENDDK | NBRNALIV | ... | SECU | SEST | CMINTVW | CMLSTYR | CMJAN3YR
    | CMJAN4YR | CMJAN5YR | QUARTER | PHASE | INTVWYEAR |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 70627 | 1 | NaN | NaN | NaN | NaN | 6.0 | NaN | NaN | 1.0 | ... | 3 |
    322 | 1394 | 1382 | 1357 | 1345 | 1333 | 18 | 1 | 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 70627 | 2 | NaN | NaN | NaN | NaN | 1.0 | NaN | NaN | NaN | ... | 3 |
    322 | 1394 | 1382 | 1357 | 1345 | 1333 | 18 | 1 | 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 70627 | 3 | NaN | NaN | NaN | NaN | 6.0 | NaN | NaN | 1.0 | ... | 3 |
    322 | 1394 | 1382 | 1357 | 1345 | 1333 | 18 | 1 | 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 70628 | 1 | NaN | NaN | NaN | NaN | 6.0 | NaN | NaN | 1.0 | ... | 2 |
    366 | 1409 | 1397 | 1369 | 1357 | 1345 | 23 | 1 | 2017 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 70628 | 2 | NaN | NaN | NaN | NaN | 6.0 | NaN | NaN | 1.0 | ... | 2 |
    366 | 1409 | 1397 | 1369 | 1357 | 1345 | 23 | 1 | 2017 |'
  prefs: []
  type: TYPE_TB
- en: 5 rows × 248 columns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|  | CASEID | PREGORDR | HOWPREG_N | HOWPREG_P | MOSCURRP | NOWPRGDK | PREGEND1
    | PREGEND2 | HOWENDDK |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 70627 | 1 | NaN | NaN | NaN | NaN | 6.0 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 70627 | 2 | NaN | NaN | NaN | NaN | 1.0 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 70627 | 3 | NaN | NaN | NaN | NaN | 6.0 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 70628 | 1 | NaN | NaN | NaN | NaN | 6.0 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 70628 | 2 | NaN | NaN | NaN | NaN | 6.0 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: The first two columns are is `CASEID` and `PREGORDR`, which I mentioned earlier.
    The first three rows have the same `CASEID`, so this respondent reported three
    pregnancies; the values of `PREGORDR` indicate that they are the first, second,
    and third pregnancies, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about the other variables as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to methods like `head`, a `Dataframe` object has several **attributes**,
    which are variables associated with the object. For example, `nsfg` has an attribute
    called `shape`, which is a tuple containing the number of rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are 9553 rows in this dataset, one for each pregnancy, and 248 columns,
    one for each variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`nsfg` also has an attribute called `columns`, which contains the column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The column names are stored in an `Index`, which is another Pandas type, similar
    to a list.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the column names, you might be able to guess what some of the variables
    are, but in general you have to read the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with datasets like the NSFG, it is important to read the documentation
    carefully. If you interpret a variable incorrectly, you can generate nonsense
    results and never realize it. So, before we start looking at data, let’s get familiar
    with the NSFG codebook, which describes every variable. You can download the codebook
    for this dataset from [https://github.com/AllenDowney/ElementsOfDataScience/raw/master/data/2015-2017_NSFG_FemPregFile_Codebook-508.pdf](https://github.com/AllenDowney/ElementsOfDataScience/raw/master/data/2015-2017_NSFG_FemPregFile_Codebook-508.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: If you search that document for “weigh at birth” you should find these variables
    related to birth weight.
  prefs: []
  type: TYPE_NORMAL
- en: '`BIRTHWGT_LB1`: Birthweight in Pounds - 1st baby from this pregnancy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BIRTHWGT_OZ1`: Birthweight in Ounces - 1st baby from this pregnancy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are similar variables for a 2nd or 3rd baby, in the case of twins or triplets.
    For now we will focus on the first baby from each pregnancy, and we will come
    back to the issue of multiple births.
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many ways a `DataFrame` is like a Python dictionary, where the column names
    are the keys and the columns are the values. You can select a column from a `DataFrame`
    using the bracket operator, with a string as the key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result is a `Series`, which is a Pandas type that represents a single column
    of data. In this case the `Series` contains the birth weight, in pounds, for each
    live birth.
  prefs: []
  type: TYPE_NORMAL
- en: '`head` shows the first five values in the `Series`, the name of the `Series`,
    and the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: One of the values is `NaN`, which stands for “Not a Number”. `NaN` is a special
    value used to indicate invalid or missing data. In this example, the pregnancy
    did not end in live birth, so birth weight is inapplicable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** The variable `BIRTHWGT_OZ1` contains the ounces part of birth
    weight.'
  prefs: []
  type: TYPE_NORMAL
- en: Select the column `'BIRTHWGT_OZ1'` from the `nsfg` `DataFrame` and assign it
    to a new variable called `ounces`. Then display the first 5 elements of `ounces`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** The Pandas types we have seen so far are `DataFrame`, `Index`,
    and `Series`. You can find the documentation of these types at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrame`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Index`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Index.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Series`: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This documentation can be overwhelming; I don’t recommend trying to read it
    all now. But you might want to skim it so you know where to look later.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point we have identified the columns we need to answer the question
    and assigned them to variables named `pounds` and `ounces`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Before we do anything with this data, we have to validate it. One part of validation
    is confirming that we are interpreting the data correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `value_counts` method to see what values appear in `pounds` and
    how many times each value appears.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By default, the results are sorted with the most frequent value first, but we
    can use `sort_index` to sort them by value instead, with the lightest babies first
    and heaviest babies last.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we’d expect, the most frequent values are 6-8 pounds, but there are some
    very light babies, a few very heavy babies, and two special values, 98, and 99\.
    According to the codebook, these values indicate that the respondent declined
    to answer the question (98) or did not know (99).
  prefs: []
  type: TYPE_NORMAL
- en: We can validate the results by comparing them to the codebook, which lists the
    values and their frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: '| value | label | Total |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| . | INAPPLICABLE | 2863 |'
  prefs: []
  type: TYPE_TB
- en: '| 0-5 | UNDER 6 POUNDS | 901 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 POUNDS | 1644 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 7 POUNDS | 2268 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 8 POUNDS | 1287 |'
  prefs: []
  type: TYPE_TB
- en: '| 9-95 | 9 POUNDS OR MORE | 499 |'
  prefs: []
  type: TYPE_TB
- en: '| 98 | Refused | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 99 | Don’t know | 89 |'
  prefs: []
  type: TYPE_TB
- en: '|  | Total | 9553 |'
  prefs: []
  type: TYPE_TB
- en: The results from `value_counts` agree with the codebook, so we have some confidence
    that we are reading and interpreting the data correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** In the `nsfg` `DataFrame`, the column `''OUTCOME''` encodes the
    outcome of each pregnancy as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Live birth |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Induced abortion |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Stillbirth |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Miscarriage |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Ectopic pregnancy |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Current pregnancy |'
  prefs: []
  type: TYPE_TB
- en: Use `value_counts` to display the values in this column and how many times each
    value appears. Are the results consistent with the codebook?
  prefs: []
  type: TYPE_NORMAL
- en: Summary Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to validate the data is with `describe`, which computes statistics
    that summarize the data, like the mean, standard deviation, minimum, and maximum.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the results for `pounds`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`count` is the number of values, not including `NaN`. For this variable, there
    are 6690 value that are not `NaN`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mean` and `std` are the mean and standard deviation. `min` and `max` are the
    minimum and maximum values, and in between are the 25th, 50th, and 75th percentiles.
    The 50th percentile is the median.'
  prefs: []
  type: TYPE_NORMAL
- en: The mean is about `8.05`, but that doesn’t mean much because it includes the
    special values 98 and 99\. Before we can really compute the mean, we have to replace
    those values with `NaN` to identify them as missing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `replace()` method does what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`replace` takes a list of the values we want to replace and the value we want
    to replace them with. `np.nan` means we are getting the special value `NaN` from
    the NumPy library, which is imported as `np`.'
  prefs: []
  type: TYPE_NORMAL
- en: The result from `replace()` is a new `Series`, which I assign to `pounds_clean`.
    If we run `describe` again, we see that `count` is smaller now because it includes
    only the valid values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The mean of the new `Series` is about 6.7 pounds. Remember that the mean of
    the original `Series` was more than 8 pounds. It makes a big difference when you
    remove a few 99-pound babies!
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Use `describe` to summarize `ounces`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then use `replace` to replace the special values 98 and 99 with NaN, and assign
    the result to `ounces_clean`. Run `describe` again. How much does this cleaning
    affect the results?
  prefs: []
  type: TYPE_NORMAL
- en: Series Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we want to combine `pounds` and `ounces` into a single `Series` that contains
    total birth weight. Arithmetic operators work with `Series` objects; so, for example,
    to convert `pounds` to ounces, we could write
  prefs: []
  type: TYPE_NORMAL
- en: '`pounds * 16`'
  prefs: []
  type: TYPE_NORMAL
- en: Then we could add in `ounces` like this
  prefs: []
  type: TYPE_NORMAL
- en: '`pounds * 16 + ounces`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Use `pounds_clean` and `ounces_clean` to compute the total birth
    weight expressed in kilograms (there are roughly 2.2 pounds per kilogram). What
    is the mean birth weight in kilograms?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** For each pregnancy in the NSFG dataset, the variable `''AGECON''`
    encodes the respondent’s age at conception, and `''AGEPREG''` the respondent’s
    age at the end of the pregnancy.'
  prefs: []
  type: TYPE_NORMAL
- en: Read the documentation of these variables. Are there any special values we have
    to deal with?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select `'AGECON'` and `'AGEPREG'` and assign them to variables named `agecon`
    and `agepreg`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute the difference, which is an estimate of the duration of the pregnancy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `.describe()` to compute the mean duration and other summary statistics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the results, it seems like this might not be a good way to estimate
    the duration of pregnancy. Why not?
  prefs: []
  type: TYPE_NORMAL
- en: Histograms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get back to the original question: what is the average birth weight for
    babies in the U.S.?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an answer we *could* take the results from the previous section and compute
    the mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: But it is risky to compute a summary statistic, like the mean, before we look
    at the whole distribution of values.
  prefs: []
  type: TYPE_NORMAL
- en: A **distribution** is a set of possible values and their frequencies. One way
    to visualize a distribution is a **histogram**, which shows values on the `x`
    axis and their frequencies on the `y` axis.
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` provides a `hist` method that makes histograms. And we can use Matplotlib
    to label the axes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![_images/07_dataframes_66_0.png](../Images/b0744351975b411829eb928c8e0df35a.png)'
  prefs: []
  type: TYPE_IMG
- en: The keyword argument, `bins`, tells `hist` to divide the range of weights into
    30 intervals, called **bins**, and count how many values fall in each bin. The
    `x` axis is birth weight in pounds; the `y` axis is the number of births in each
    bin.
  prefs: []
  type: TYPE_NORMAL
- en: The distribution looks a little like a bell curve, but the tail is longer on
    the left than on the right; that is, there are more light babies than heavy babies.
    That makes sense, because the distribution includes some babies that were born
    preterm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** `hist` takes keyword arguments that specify the type and appearance
    of the histogram. Find the documentation of `hist` and see if you can figure out
    how to plot the histogram as an unfilled line against a background with no grid
    lines.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** As we saw in a previous exercise, the NSFG dataset includes a
    column called `AGECON` that records age at conception for each pregnancy.'
  prefs: []
  type: TYPE_NORMAL
- en: Select this column from the `DataFrame` and plot the histogram of the values
    with 20 bins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Label the `x` and `y` axes appropriately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen that the distribution of birth weights is **skewed** to the left;
    that is, there are more light babies than heavy ones and they are farther from
    the mean. That’s because preterm babies tend to be lighter. The most common duration
    for pregnancy is 39 weeks, which is “full term”; “preterm” is usually defined
    to be less than 37 weeks.
  prefs: []
  type: TYPE_NORMAL
- en: To see which babies are preterm, we can use `PRGLNGTH`, which records pregnancy
    length in weeks and compute it to `37`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When you compare a `Series` to a value, the result is a Boolean `Series`; that
    is, a `Series` where each element is a Boolean value, `True` or `False`. In this
    case, it’s `True` for each preterm baby and `False` otherwise. We can use `head`
    to see the first 5 elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you compute the sum of a Boolean `Series`, it treats `True` as 1 and `False`
    as 0, so the sum is the number of `True` values, which is the number of preterm
    babies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you compute the mean of a Boolean `Series`, you get the *fraction* of `True`
    values. In this case, it’s about 0.38; that is, about 38% of the pregnancies are
    less than 37 weeks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this result might be misleading because it includes all pregnancy
    outcomes, not just live births. We can create another Boolean `Series` to indicate
    which pregnancies ended in live birth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the operator `&`, which represents the logical AND operation,
    to identify pregnancies where the outcome is a live birth and preterm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise:** Of all live births, what fraction are preterm?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other common logical operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`|`, which represents the logical OR operation; for example `live | preterm`
    is true if either `live` is true, or `preterm` is true, or both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~`, which represents the logical NOT operation; for example `~live` is true
    if `live` is false or `NaN`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical operators treat `NaN` the same as `False`, so you should be careful
    about using the NOT operator with a Series that contains `NaN` values. For example,
    `~preterm` would include not just full term pregnancies, but also pregnancies
    with unknown length.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Of all pregnancies, what fraction are full term, that is, 37
    weeks or more? Of all live births, what fraction are full term?'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use a Boolean `Series` as a filter; that is, we can select only rows
    that satisfy a condition or meet some criterion. For example, we can use `preterm`
    and the bracket operator to select values from `birth_weight`, so `preterm_weight`
    gets birth weights for preterm babies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To select full-term babies, we can create a Boolean `Series` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And use it to select birth weights for full term babies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, full term babies are heavier, on average, than preterm babies.
    To be more explicit, we could also limit the results to live births, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: But in this case we get the same result because `birth_weight` is only valid
    for live births.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Let’s see if there is a difference in weight between single births
    and multiple births (twins, triplets, etc.). The variable `NBRNALIV` represents
    the number of babies born alive from a single pregnancy.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Use `nbrnaliv` and `live` to create a Boolean series called `multiple` that
    is true for multiple live births. Of all live births, what fraction are multiple
    births?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Make a Boolean series called `single` that is true for single
    live births. Of all single births, what fraction are preterm? Of all multiple
    births, what fraction are preterm?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** What is the average birth weight for live, single, full-term
    births?'
  prefs: []
  type: TYPE_NORMAL
- en: Weighted Means
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are almost done, but there’s one more problem we have to solve: oversampling.'
  prefs: []
  type: TYPE_NORMAL
- en: The NSFG is not exactly representative of the U.S. population. By design, some
    groups are more likely to appear in the sample than others; that is, they are
    **oversampled**. Oversampling helps to ensure that you have enough people in every
    subgroup to get reliable statistics, but it makes data analysis a little more
    complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Each pregnancy in the dataset has a **sampling weight** that indicates how many
    pregnancies it represents. In `nsfg`, the sampling weight is stored in a column
    named `wgt2015_2017`. Here’s what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The median value (50th percentile) in this column is about 7292, which means
    that a pregnancy with that weight represents 7292 total pregnancies in the population.
    But the range of values is wide, so some rows represent many more pregnancies
    than others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take these weights into account, we can compute a **weighted mean**. Here
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiply the birth weights for each pregnancy by the sampling weights and add
    up the products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add up the sampling weights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide the first sum by the second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this correctly, we have to be careful with missing data. To help with
    that, we’ll use two `Series` methods, `isna` and `notna`.
  prefs: []
  type: TYPE_NORMAL
- en: '`isna` returns a Boolean `Series` that is `True` where the corresponding value
    is `NaN`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In `birth_weight` there are 3013 missing values (mostly for pregnancies that
    did not end in live birth).
  prefs: []
  type: TYPE_NORMAL
- en: '`notna` returns a Boolean `Series` that is `True` where the corresponding value
    is *not* `NaN`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We can combine `valid` with the other Boolean `Series` we have computed to identify
    single, full term, live births with valid birth weights.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can finish off this computation as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Use `selected`, `birth_weight`, and `sampling_weight` to compute
    the weighted mean of birth weight for live, single, full term births.'
  prefs: []
  type: TYPE_NORMAL
- en: You should find that the weighted mean is a little higher than the unweighted
    mean we computed in the previous section. That’s because the groups that are oversampled
    in the NSFG tend to have lighter babies, on average.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter poses what seems like a simple question: what is the average birth
    weight of babies in the United States?'
  prefs: []
  type: TYPE_NORMAL
- en: To answer it, we found an appropriate dataset and read the files. Then we validated
    the data and dealt with special values, missing data, and errors. To explore the
    data, we used `value_counts`, `hist`, `describe`, and other Pandas methods. And
    to select relevant data, we used Boolean `Series`.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we had to think more about the question. What do we mean by “average”,
    and which babies should we include? Should we include all live births or exclude
    preterm babies or multiple births?
  prefs: []
  type: TYPE_NORMAL
- en: And we had to think about the sampling process. By design, the NSFG respondents
    are not representative of the U.S. population, but we can use sampling weights
    to correct for this effect.
  prefs: []
  type: TYPE_NORMAL
- en: Even a simple question can be a challenging data science project.
  prefs: []
  type: TYPE_NORMAL
