# 第一章：探索性数据分析

> 原文：[`greenteapress.com/thinkstats2/html/thinkstats2002.html`](https://greenteapress.com/thinkstats2/html/thinkstats2002.html)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)


本书的论点是，数据结合实用方法可以在不确定性下回答问题并指导决策。

举例来说，我提出了一个案例研究，这是我在我和妻子期待第一个孩子时听到的一个问题：第一个孩子是否倾向于出生晚？

如果你在谷歌上搜索这个问题，你会找到很多讨论。有些人声称这是真的，其他人说这是一个谬论，还有些人说情况正好相反：第一个孩子会提前出生。

在许多讨论中，人们提供数据来支持他们的观点。我发现了许多这样的例子：

> “我有两个朋友最近生了他们的第一个孩子，两个都超过预产期将近两周才开始分娩或被引产。”
> 
> “我的第一个孩子晚了两周才出生，现在我觉得第二个孩子可能会提前两周出生！”
> 
> “我不认为这可能是真的，因为我姐姐是我妈妈的第一个孩子，她出生得很早，我的许多表兄弟姐妹也是如此。”

这样的报告被称为轶事证据，因为它们是基于未发表的个人数据。在随意的谈话中，轶事没有问题，所以我并不是在挑剔我引用的人。

但我们可能希望有更有说服力的证据和更可靠的答案。按这些标准，轶事证据通常是不可靠的，因为：

+   观察次数较少：如果第一胎的怀孕期较长，与自然变异相比，差异可能很小。在这种情况下，我们可能需要比较大量的怀孕情况，以确保存在差异。

+   选择偏倚：加入这个问题讨论的人可能是因为他们的第一个孩子出生晚。在这种情况下，选择数据的过程会使结果产生偏差。

+   确认偏见：相信这个说法的人可能更有可能提供证实它的例子。怀疑这个说法的人更有可能引用反例。

+   不准确性：轶事往往是个人故事，经常记错、曲解、重复不准确等。

那么我们该如何做得更好呢？

## 1.1 统计方法

为了解决轶事的局限性，我们将使用统计工具，其中包括：

+   数据收集：我们将使用大型全国调查的数据，该调查旨在明确设计，以实现对美国人口的统计有效推断。

+   描述统计：我们将生成概括数据的统计数据，并评估不同的数据可视化方式。

+   探索性数据分析：我们将寻找模式、差异和其他特征，以解决我们感兴趣的问题。与此同时，我们将检查不一致之处并确定局限性。

+   估计：我们将使用样本数据来估计一般人口的特征。

+   假设检验：当我们看到明显的效应时，比如两组之间的差异，我们将评估这种效应是否可能是偶然发生的。

通过谨慎地执行这些步骤以避免陷阱，我们可以得出更有道理和更有可能正确的结论。

## 1.2 全国家庭增长调查

自 1973 年以来，美国疾病控制和预防中心（CDC）进行了全国家庭增长调查（NSFG），旨在收集“有关家庭生活、婚姻和离婚、怀孕、不孕不育、避孕使用以及男性和女性健康的信息。调查结果被用来……规划卫生服务和卫生教育项目，并对家庭、生育率和健康进行统计研究。”见[`cdc.gov/nchs/nsfg.htm`](http://cdc.gov/nchs/nsfg.htm)。

我们将使用此调查收集的数据来调查第一个宝宝是否往往出生较晚，以及其他问题。为了有效使用这些数据，我们必须了解研究的设计。

NSFG 是一项横断面研究，这意味着它在某个时间点捕捉了一个群体的快照。最常见的替代方案是纵向研究，它在一段时间内反复观察一个群体。

NSFG 已经进行了七次；每次部署被称为一个周期。我们将使用第 6 周期的数据，该周期从 2002 年 1 月到 2003 年 3 月进行。

调查的目标是对人口做出结论；NSFG 的目标人口是美国 15-44 岁的人。理想情况下，调查应该收集到人口的每个成员的数据，但这很少可能。相反，我们从人口的一个子集，称为样本，收集数据。参与调查的人被称为受访者。

一般来说，横断面研究的目的是要具有代表性，这意味着目标人口的每个成员都有平等的参与机会。在实践中很难实现这一理想，但进行调查的人尽可能接近。

NSFG 并不具有代表性；相反，它是故意过度抽样的。研究的设计者以比美国人口中的比例更高的比例招募了三组人——西班牙裔、非裔美国人和青少年，以确保这些群体中的受访者数量足够大，可以得出有效的统计推断。

当然，过度抽样的缺点是，根据调查统计数据很难对一般人口做出结论。我们将在后面回到这一点。

在处理这种数据时，熟悉代码簿是很重要的，它记录了研究的设计、调查问题和响应的编码。NSFG 数据的代码簿和用户指南可从[`www.cdc.gov/nchs/nsfg/nsfg_cycle6.htm`](http://www.cdc.gov/nchs/nsfg/nsfg_cycle6.htm)获取。

## 1.3 导入数据

本书中使用的代码和数据可从[`github.com/AllenDowney/ThinkStats2`](https://github.com/AllenDowney/ThinkStats2)获取。有关下载和使用此代码的信息，请参见第 0.2 节。

下载代码后，您应该有一个名为`ThinkStats2/code/nsfg.py`的文件。如果运行它，它应该读取一个数据文件，运行一些测试，并打印一条消息，如“所有测试通过”。

让我们看看它的作用。NSFG 第 6 周期的怀孕数据存储在一个名为`2002FemPreg.dat.gz`的文件中；这是一个 gzip 压缩的纯文本（ASCII）数据文件，具有固定宽度的列。文件中的每一行都是包含有关一次怀孕的数据的记录。

文件的格式在`2002FemPreg.dct`中有记录，这是一个 Stata 字典文件。Stata 是一个统计软件系统；在这个上下文中，“字典”是一个变量名称、类型和索引的列表，用于标识在每行中找到每个变量的位置。

例如，这是`2002FemPreg.dct`中的几行：

```py
infile dictionary {
  _column(1)  str12  caseid    %12s  "RESPONDENT ID NUMBER"
  _column(13) byte   pregordr   %2f  "PREGNANCY ORDER (NUMBER)"
} 
```

这个词典描述了两个变量：`caseid`是一个 12 个字符的字符串，代表受访者 ID；`pregordr`是一个一字节整数，表示该受访者的怀孕顺序。

您下载的代码包括`thinkstats2.py`，这是一个 Python 模块，包含本书中使用的许多类和函数，包括读取 Stata 字典和 NSFG 数据文件的函数。以下是它们在`nsfg.py`中的使用方式：

```py
def ReadFemPreg(dct_file='2002FemPreg.dct',
                dat_file='2002FemPreg.dat.gz'):
    dct = thinkstats2.ReadStataDct(dct_file)
    df = dct.ReadFixedWidth(dat_file, compression='gzip')
    CleanFemPreg(df)
    return df 
```

`ReadStataDct`接受字典文件的名称，并返回`dct`，一个包含字典文件信息的`FixedWidthVariables`对象。`dct`提供`ReadFixedWidth`，用于读取数据文件。

## 1.4 数据框

`ReadFixedWidth`的结果是一个 DataFrame，这是 pandas 提供的基本数据结构，它是一个 Python 数据和统计包，我们将在本书中使用。DataFrame 包含每条记录的一行，在本例中是每次怀孕的一行，以及每个变量的一列。

除了数据，DataFrame 还包含变量名称和它们的类型，并提供了访问和修改数据的方法。

如果你打印`df`，你会得到行和列的截断视图，以及 DataFrame 的形状，即 13593 行/记录和 244 列/变量。

```py
>>> import nsfg
>>> df = nsfg.ReadFemPreg()
>>> df
...
[13593 rows x 244 columns] 
```

DataFrame 太大无法显示，因此输出被截断。最后一行报告了行数和列数。

属性`columns`返回一系列列名作为 Unicode 字符串：

```py
>>> df.columns
Index([u'caseid', u'pregordr', u'howpreg_n', u'howpreg_p', ... ]) 
```

结果是一个索引，这是另一个 pandas 数据结构。我们稍后会更多地了解索引，但现在我们会把它当作一个列表：

```py
>>> df.columns[1]
'pregordr' 
```

要从 DataFrame 中访问列，你可以使用列名作为键：

```py
>>> pregordr = df['pregordr']
>>> type(pregordr)
<class 'pandas.core.series.Series'> 
```

结果是一个 Series，又是另一个 pandas 数据结构。Series 就像一个带有一些额外功能的 Python 列表。当你打印一个 Series 时，你会得到索引和相应的值：

```py
>>> pregordr
0     1
1     2
2     1
3     2
...
13590    3
13591    4
13592    5
Name: pregordr, Length: 13593, dtype: int64 
```

在这个例子中，索引是从 0 到 13592 的整数，但一般来说它们可以是任何可排序的类型。元素也是整数，但它们可以是任何类型。

最后一行包括变量名、Series 长度和数据类型；`int64`是 NumPy 提供的类型之一。如果你在 32 位机器上运行这个例子，你可能会看到`int32`。

你可以使用整数索引和切片访问 Series 的元素：

```py
>>> pregordr[0]
1
>>> pregordr[2:5]
2    1
3    2
4    3
Name: pregordr, dtype: int64 
```

索引运算符的结果是`int64`；切片的结果是另一个 Series。

你也可以使用点符号访问 DataFrame 的列：

```py
>>> pregordr = df.pregordr 
```

这种表示法只有在列名是有效的 Python 标识符时才有效，因此必须以字母开头，不能包含空格等。

## 1.5  变量

我们已经在 NSFG 数据集中看到了两个变量，`caseid`和`pregordr`，并且我们已经知道总共有 244 个变量。在本书的探索中，我使用以下变量：

+   `caseid`是受访者的整数 ID。

+   `prglngth`是怀孕持续的整数周数。

+   `outcome`是怀孕结果的整数代码。代码 1 表示活产。

+   `pregordr`是怀孕的序号；例如，受访者的第一次怀孕的代码是 1，第二次怀孕的代码是 2，依此类推。

+   `birthord`是活产的序号；受访者的第一个孩子的代码是 1，依此类推。对于除活产以外的结果，这个字段是空白的。

+   `birthwgt_lb`和`birthwgt_oz`包含宝宝出生体重的磅和盎司部分。

+   `agepreg`是母亲怀孕结束时的年龄。

+   `finalwgt`是与受访者相关的统计权重。它是一个浮点值，表示这个受访者代表的美国人口数量。

如果你仔细阅读代码簿，你会发现许多变量是重新编码的，这意味着它们不是调查收集的原始数据的一部分；它们是使用原始数据计算出来的。

例如，活产的`prglngth`等于原始变量`wksgest`（妊娠周数）如果可用；否则，它将使用`mosgest * 4.33`（妊娠月数乘以一个月的平均周数）进行估算。

重新编码通常基于检查数据的一致性和准确性的逻辑。一般来说，最好在可用时使用重新编码，除非有充分的理由自己处理原始数据。

## 1.6  转换

当你像这样导入数据时，你经常需要检查错误，处理特殊值，将数据转换为不同的格式，并进行计算。这些操作被称为数据清理。

`nsfg.py`包括`CleanFemPreg`，一个用于清理我打算使用的变量的函数。

```py
def CleanFemPreg(df):
    df.agepreg /= 100.0

    na_vals = [97, 98, 99]
    df.birthwgt_lb.replace(na_vals, np.nan, inplace=True)
    df.birthwgt_oz.replace(na_vals, np.nan, inplace=True)

    df['totalwgt_lb'] = df.birthwgt_lb + df.birthwgt_oz / 16.0 
```

`agepreg`包含母亲怀孕结束时的年龄。在数据文件中，`agepreg`被编码为以百年为单位的整数。因此，第一行将`agepreg`的每个元素除以 100，得到年份的浮点值。

`birthwgt_lb`和`birthwgt_oz`包含婴儿的体重，以磅和盎司为单位，对于以活产结束的怀孕。此外，它使用了几个特殊的代码：

```py
97      NOT ASCERTAINED
98      REFUSED
99      DON'T KNOW 
```

将特殊值编码为数字是*危险*的，因为如果它们没有得到适当处理，它们可能会产生错误的结果，比如一个 99 磅的婴儿。`replace`方法用`np.nan`替换这些值，`np.nan`是一个特殊的浮点值，表示“不是一个数字”。`inplace`标志告诉`replace`修改现有的 Series 而不是创建一个新的。

作为 IEEE 浮点标准的一部分，如果任一参数为`nan`，则所有数学运算都会返回`nan`：

```py
>>> import numpy as np
>>> np.nan / 100.0
nan 
```

因此，对`nan`的计算往往会得到正确的结果，大多数 pandas 函数会适当地处理`nan`。但处理缺失数据将是一个经常出现的问题。

`CleanFemPreg`的最后一行创建了一个名为`totalwgt_lb`的新列，将磅和盎司合并为一个数量，以磅为单位。

一个重要的注意事项：当向 DataFrame 添加新列时，必须使用字典语法，就像这样

```py
 # CORRECT
    df['totalwgt_lb'] = df.birthwgt_lb + df.birthwgt_oz / 16.0 
```

不是点表示法，就像这样：

```py
 # WRONG!
    df.totalwgt_lb = df.birthwgt_lb + df.birthwgt_oz / 16.0 
```

带有点表示法的版本向 DataFrame 对象添加了一个属性，但该属性不被视为一个新列。

## 1.7 验证

当数据从一个软件环境导出并导入到另一个软件环境时，可能会引入错误。当您熟悉新数据集时，您可能会错误地解释数据或引入其他误解。如果您花时间验证数据，您可以节省后续的时间并避免错误。

验证数据的一种方法是计算基本统计数据，并将其与已发布的结果进行比较。例如，NSFG 代码手册包括总结每个变量的表格。这是`outcome`的表格，它编码了每次怀孕的结果：

```py
value   label                  Total
1       LIVE BIRTH              9148
2       INDUCED ABORTION        1862
3       STILLBIRTH               120
4       MISCARRIAGE             1921
5       ECTOPIC PREGNANCY        190
6       CURRENT PREGNANCY        352 
```

Series 类提供了一个`value_counts`方法，用于计算每个值出现的次数。如果我们从 DataFrame 中选择`outcome` Series，我们可以使用`value_counts`与已发布的数据进行比较：

```py
>>> df.outcome.value_counts().sort_index()
1    9148
2    1862
3     120
4    1921
5     190
6     352 
```

`value_counts`的结果是一个 Series；`sort_index()`按索引对 Series 进行排序，因此值会按顺序出现。

与已发布的表格进行比较，看起来`outcome`中的值是正确的。同样，这是`birthwgt_lb`的已发布表格

```py
value   label                  Total
.       INAPPLICABLE            4449
0-5     UNDER 6 POUNDS          1125
6       6 POUNDS                2223
7       7 POUNDS                3049
8       8 POUNDS                1889
9-95    9 POUNDS OR MORE         799 
```

以下是值计数：

```py
>>> df.birthwgt_lb.value_counts(sort=False)
0        8
1       40
2       53
3       98
4      229
5      697
6     2223
7     3049
8     1889
9      623
10     132
11      26
12      10
13       3
14       3
15       1
51       1 
```

6、7 和 8 磅的计数是正确的，如果您将 0-5 和 9-95 的计数相加，它们也是正确的。但是如果您仔细观察，您会注意到一个值必须是错误的，即 51 磅的婴儿！

为了处理这个错误，我在`CleanFemPreg`中添加了一行：

```py
df.loc[df.birthwgt_lb > 20, 'birthwgt_lb'] = np.nan 
```

该语句用`np.nan`替换无效值。属性`loc`提供了从 DataFrame 中选择行和列的几种方法。在这个例子中，方括号中的第一个表达式是行索引器；第二个表达式选择列。

表达式`df.birthwgt_lb > 20`产生了一个`bool`类型的 Series，其中 True 表示条件为真。当布尔 Series 用作索引时，它只选择满足条件的元素。

## 1.8 解释

要有效地处理数据，您必须同时考虑统计水平和上下文水平。

举个例子，让我们看看一些受访者的结果序列。由于数据文件的组织方式，我们必须进行一些处理，以收集每个受访者的怀孕数据。这是一个可以做到这一点的函数：

```py
def MakePregMap(df):
    d = defaultdict(list)
    for index, caseid in df.caseid.iteritems():
        d[caseid].append(index)
    return d 
```

`df`是包含怀孕数据的 DataFrame。`iteritems`方法枚举了每次怀孕的索引（行号）和`caseid`。

`d`是一个将每个案例 ID 映射到索引列表的字典。如果你不熟悉`defaultdict`，它在 Python 的`collections`模块中。使用`d`，我们可以查找一个受访者，并获得该受访者怀孕的索引。

这个例子查找一个受访者，并打印出她怀孕的结果列表：

```py
>>> caseid = 10229
>>> preg_map = nsfg.MakePregMap(df)
>>> indices = preg_map[caseid]
>>> df.outcome[indices].values
[4 4 4 4 4 4 1] 
```

`indices`是与受访者`10229`对应的怀孕索引列表。

使用这个列表作为`df.outcome`的索引选择指定的行，并产生一个 Series。我选择了`values`属性，它是一个 NumPy 数组，而不是打印整个 Series。

结果代码`1`表示活产。代码`4`表示流产；即自然结束的怀孕，通常没有已知的医学原因。

从统计学上讲，这个受访者并不罕见。流产很常见，还有其他受访者报告的流产次数可能更多。

但是记住背景，这些数据讲述了一个女性怀孕六次，每次都以流产结束的故事。她的第七次和最近的怀孕以活产结束。如果我们怀着同情心来考虑这些数据，被它所讲述的故事感动是很自然的。

NSFG 数据集中的每条记录代表一个诚实回答了许多个人和困难问题的人。我们可以利用这些数据来回答关于家庭生活、生育和健康的统计问题。与此同时，我们有义务考虑数据所代表的人，并对他们表示尊重和感激。

## 1.9 练习

练习 1 在你下载的存储库中，你应该找到一个名为`chap01ex.ipynb`的文件，这是一个 IPython 笔记本。你可以像这样从命令行启动 IPython 笔记本：

```py
*$ ipython notebook &* 
```

如果 IPython 已安装，它应该启动一个在后台运行的服务器，并打开一个浏览器来查看笔记本。如果你不熟悉 IPython，我建议你从 http://ipython.org/ipython-doc/stable/notebook/notebook.html 开始。

要启动 IPython 笔记本服务器，请运行：

```py
*$ ipython notebook &* 
```

它应该打开一个新的浏览器窗口，但如果没有，启动消息会提供一个 URL，你可以在浏览器中加载，通常是 http://localhost:8888。新窗口应该列出存储库中的笔记本。

打开`chap01ex.ipynb`。有些单元格已经填写好了，你应该执行它们。其他单元格给出了你应该尝试的练习的说明。

这个练习的解决方案在`chap01soln.ipynb`中。

练习 2 在你下载的存储库中，你应该找到一个名为`chap01ex.py`的文件；使用这个文件作为起点，编写一个函数，读取受访者文件`2002FemResp.dat.gz`。

变量`pregnum`是一个重新编码，表示每个受访者怀孕的次数。打印这个变量的值计数，并将其与 NSFG 代码手册中的已发布结果进行比较。

你还可以通过比较每个受访者的`pregnum`与怀孕文件中的记录数来交叉验证受访者和怀孕文件。

你可以使用`nsfg.MakePregMap`来创建一个字典，将每个`caseid`映射到怀孕 DataFrame 中的索引列表。

这个练习的解决方案在`chap01soln.py`中。

练习 3 学习统计学的最佳方法是研究你感兴趣的项目。有没有像“第一个宝宝会晚到吗”这样的问题你想调查的？

想想你个人感兴趣的问题，或者传统智慧的项目，或者有争议的话题，或者具有政治后果的问题，并看看是否能够制定一个适合统计调查的问题。

*寻找数据来帮助你解决问题。政府是很好的信息来源，因为公共研究的数据通常是免费提供的。开始寻找的好地方包括* [*http://www.data.gov/*](http://www.data.gov/)*，以及* [*http://www.science.gov/*](http://www.science.gov/)*，在英国，还有* [*http://data.gov.uk/*](http://data.gov.uk/)*。*

*我最喜欢的两个数据集是* [*http://www3.norc.org/gss+website/*](http://www3.norc.org/gss+website/)* *的《美国社会总体调查》和* [*http://www.europeansocialsurvey.org/*](http://www.europeansocialsurvey.org/)* *的《欧洲社会调查》。*

*如果看起来有人已经回答了你的问题，仔细看看答案是否合理。数据或分析可能存在缺陷，使得结论不可靠。在这种情况下，你可以对相同数据进行不同的分析，或寻找更好的数据来源。*

*如果你找到一篇回答你问题的发表论文，你应该能够获得原始数据。许多作者会在网上公开他们的数据，但对于敏感数据，你可能需要写信给作者，提供关于你计划如何使用数据的信息，或同意一些使用条款。要坚持不懈！*

## 1.10 术语表

+   个别证据：通常是个人收集的证据，而不是通过设计良好的研究收集的。

+   人群：我们有兴趣研究的群体。“人群”通常指一群人，但这个术语也用于其他主题。

+   横断面研究：在特定时间点收集关于人群的数据的研究。

+   周期：在重复的横断面研究中，每次重复研究称为一个周期。

+   纵向研究：一项随时间跟踪人群的研究，重复收集同一群体的数据。

+   记录：在数据集中，关于单个人或其他主题的信息集合。

+   受访者：回答调查的人。

+   样本：用于收集数据的人群的子集。

+   代表性：如果人群的每个成员被选入样本的机会相同，则样本是代表性的。

+   过采样：增加子群体的代表性以避免由于样本量过小而产生的错误的技术。

+   原始数据：收集和记录的数值，几乎没有经过检查、计算或解释。

+   重编码：通过计算和其他逻辑应用于原始数据而生成的值。

+   数据清理：包括验证数据、识别错误、在不同数据类型和表示之间进行转换等过程。
