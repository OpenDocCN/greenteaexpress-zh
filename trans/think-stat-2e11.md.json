["```py\nres = ys - (inter + slope * xs) \n```", "```py\ndef LeastSquares(xs, ys):\n    meanx, varx = MeanVar(xs)\n    meany = Mean(ys)\n\n    slope = Cov(xs, ys, meanx, meany) / varx\n    inter = meany - slope * meanx\n\n    return inter, slope \n```", "```py\ndef FitLine(xs, inter, slope):\n    fit_xs = np.sort(xs)\n    fit_ys = inter + slope * fit_xs\n    return fit_xs, fit_ys \n```", "```py\n live, firsts, others = first.MakeFrames()\n    live = live.dropna(subset=['agepreg', 'totalwgt_lb'])\n    ages = live.agepreg\n    weights = live.totalwgt_lb\n\n    inter, slope = thinkstats2.LeastSquares(ages, weights)\n    fit_xs, fit_ys = thinkstats2.FitLine(ages, inter, slope) \n```", "```py\ndef Residuals(xs, ys, inter, slope):\n    xs = np.asarray(xs)\n    ys = np.asarray(ys)\n    res = ys - (inter + slope * xs)\n    return res \n```", "```py\ndef SamplingDistributions(live, iters=101):\n    t = []\n    for _ in range(iters):\n        sample = thinkstats2.ResampleRows(live)\n        ages = sample.agepreg\n        weights = sample.totalwgt_lb\n        estimates = thinkstats2.LeastSquares(ages, weights)\n        t.append(estimates)\n\n    inters, slopes = zip(*t)\n    return inters, slopes \n```", "```py\ndef ResampleRows(df):\n    return SampleRows(df, len(df), replace=True) \n```", "```py\ndef Summarize(estimates, actual=None):\n    mean = thinkstats2.Mean(estimates)\n    stderr = thinkstats2.Std(estimates, mu=actual)\n    cdf = thinkstats2.Cdf(estimates)\n    ci = cdf.ConfidenceInterval(90)\n    print('mean, SE, CI', mean, stderr, ci) \n```", "```py\ndef PlotConfidenceIntervals(xs, inters, slopes,\n                            percent=90, **options):\n    fys_seq = []\n    for inter, slope in zip(inters, slopes):\n        fxs, fys = thinkstats2.FitLine(xs, inter, slope)\n        fys_seq.append(fys)\n\n    p = (100 - percent) / 2\n    percents = p, 100 - p\n    low, high = thinkstats2.PercentileRows(fys_seq, percents)\n    thinkplot.FillBetween(fxs, low, high, **options) \n```", "```py\ndef CoefDetermination(ys, res):\n    return 1 - Var(res) / Var(ys) \n```", "```py\n>>> var_ys = 15**2\n>>> rho = 0.72\n>>> r2 = rho**2\n>>> var_res = (1 - r2) * var_ys\n>>> std_res = math.sqrt(var_res)\n10.4096 \n```", "```py\nclass SlopeTest(thinkstats2.HypothesisTest):\n\n    def TestStatistic(self, data):\n        ages, weights = data\n        _, slope = thinkstats2.LeastSquares(ages, weights)\n        return slope\n\n    def MakeModel(self):\n        _, weights = self.data\n        self.ybar = weights.mean()\n        self.res = weights - self.ybar\n\n    def RunModel(self):\n        ages, _ = self.data\n        weights = self.ybar + np.random.permutation(self.res)\n        return ages, weights \n```", "```py\n live, firsts, others = first.MakeFrames()\n    live = live.dropna(subset=['agepreg', 'totalwgt_lb'])\n    ht = SlopeTest((live.agepreg, live.totalwgt_lb))\n    pvalue = ht.PValue() \n```", "```py\n inters, slopes = SamplingDistributions(live, iters=1001)\n    slope_cdf = thinkstats2.Cdf(slopes)\n    pvalue = slope_cdf[0] \n```", "```py\ndef ResampleRowsWeighted(df, column='finalwgt'):\n    weights = df[column]\n    cdf = Cdf(dict(weights))\n    indices = cdf.Sample(len(weights))\n    sample = df.loc[indices]\n    return sample \n```", "```py\n estimates = [ResampleRows(live).totalwgt_lb.mean()\n                 for _ in range(iters)] \n```", "```py\n estimates = [ResampleRowsWeighted(live).totalwgt_lb.mean()\n                 for _ in range(iters)] \n```"]