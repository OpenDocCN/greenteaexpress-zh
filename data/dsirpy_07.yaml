- en: Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 原文：[https://allendowney.github.io/DSIRP/set.html](https://allendowney.github.io/DSIRP/set.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/DSIRP/set.html](https://allendowney.github.io/DSIRP/set.html)
- en: '[Click here to run this chapter on Colab](https://colab.research.google.com/github/AllenDowney/DSIRP/blob/main/notebooks/set.ipynb)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击这里在Colab上运行这一章节](https://colab.research.google.com/github/AllenDowney/DSIRP/blob/main/notebooks/set.ipynb)'
- en: Set operators and methods
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合运算符和方法
- en: 'The following example is based on Luciano Ramalho’s talk, [Set Practice: Learning
    from Python’s set type](https://www.youtube.com/watch?v=tGAngdU_8D8).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例基于Luciano Ramalho的演讲，[集合实践：从Python的集合类型中学习](https://www.youtube.com/watch?v=tGAngdU_8D8)。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Checking membership is constant time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 检查成员资格是常数时间。
- en: '[PRE6]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Intersection is like AND: it returns elements in f AND in p.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 交集就像AND：它返回f和p中的元素。
- en: '[PRE10]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Union is like OR: it returns elements in f OR in p.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并集就像OR：它返回f或p中的元素。
- en: '[PRE12]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Symmetric difference is like XOR: elements from `f` OR `p` but not both.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对称差异就像XOR：来自`f`或`p`但不是两者的元素。
- en: '[PRE14]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here are the Fibonacci numbers that are not prime.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不是素数的斐波那契数。
- en: '[PRE16]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And the primes that are not Fibonacci numbers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 和不是斐波那契数的素数。
- en: '[PRE18]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The comparison operators check for subset and superset relationships.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符检查子集和超集关系。
- en: The Fibonacci numbers are not a superset of the primes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数不是素数的超集。
- en: '[PRE20]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And the primes are not a superset of the Fibonacci numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 而且素数不是斐波那契数的超集。
- en: '[PRE22]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In that sense, sets are not like numbers: they are only [partially ordered](https://en.wikipedia.org/wiki/Partially_ordered_set).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，集合不像数字：它们只是[部分有序](https://en.wikipedia.org/wiki/Partially_ordered_set)。
- en: '`f` is a superset of `{1, 2, 3}`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`是`{1, 2, 3}`的超集'
- en: '[PRE24]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sets provide methods as well as operators. Why?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 集合提供方法以及运算符。为什么？
- en: For one thing, the argument you pass to a method can be any iterable, not just
    a set.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，传递给方法的参数可以是任何可迭代对象，而不仅仅是一个集合。
- en: '[PRE28]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Methods also accept more than one argument:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也接受多个参数：
- en: '[PRE32]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you don’t have a set to start with, you can use an empty set.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有一个集合可以开始，你可以使用一个空集。
- en: '[PRE34]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'One small syntax nuisance: `{1, 2, 3}` is a set, but `{}` is an empty dictionary.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的语法麻烦：`{1, 2, 3}`是一个集合，但`{}`是一个空字典。
- en: Spelling Bee
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拼字比赛
- en: '[The New York Times Spelling Bee](https://www.nytimes.com/puzzles/spelling-bee)
    is a daily puzzle where the goal is to spell as many words as possible using only
    the given set of seven letters. For example, in a recent Spelling Bee, the available
    letters were `dehiklo`, so you could spell “like” and “hold”.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[纽约时报拼字比赛](https://www.nytimes.com/puzzles/spelling-bee)是一个每日谜题，目标是仅使用给定的七个字母拼写尽可能多的单词。例如，在最近的拼字比赛中，可用的字母是`dehiklo`，所以你可以拼写“like”和“hold”。'
- en: You can use each of the letters more than once, so “hook” and “deed” would be
    allowed, too.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以多次使用每个字母，所以“hook”和“deed”也是允许的。
- en: To make it a little more interesting, one of the letters is special and must
    be included in every word. In this example, the special letter is `o`, so “hood”
    would be allowed, but not “like”.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它更有趣，其中一个字母是特殊的，必须包含在每个单词中。在这个例子中，特殊字母是`o`，所以“hood”是允许的，但“like”不是。
- en: Each word you find scores points depending on it’s length, which must be at
    least four letters. A word that uses all of the letters is called a “pangram”
    and scores extra points.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到的每个单词都根据它的长度得分，长度至少为四个字母。使用所有字母的单词称为“全字母句”，并且得到额外的分数。
- en: We’ll use this puzzle to explore the use of Python sets.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个谜题来探索Python集合的使用。
- en: Suppose we’re given a word and we would like to know whether it can be spelled
    using only a given set of letters. The following function solves this problem
    using string operations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个单词，我们想知道它是否可以只用给定的字母集拼写。以下函数使用字符串操作解决了这个问题。
- en: '[PRE36]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we find any letters in `word` that are not in the list of letters, we can
    return `False` immediately. If we get through the word without finding any unavailable
    letters, we can return `True`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`word`中找到任何不在字母列表中的字母，我们可以立即返回`False`。如果我们在单词中没有找到任何不可用的字母，我们可以返回`True`。
- en: Let’s try it out with some examples. In a recent Spelling Bee, the available
    letters were `dehiklo`. Let’s see what we can spell with them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些例子来试试。在最近的拼字比赛中，可用的字母是`dehiklo`。让我们看看我们能用它们拼出什么。
- en: '[PRE37]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Exercise:** It is possible to implement `uses_only` more concisely using
    set operations rather than list operations. [Read the documentation of the `set`
    class](https://docs.python.org/3/tutorial/datastructures.html#sets) and rewrite
    `uses_only` using sets.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：可以使用集合操作而不是列表操作更简洁地实现`uses_only`。[阅读`set`类的文档](https://docs.python.org/3/tutorial/datastructures.html#sets)并使用集合重写`uses_only`。
- en: '[PRE41]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Word list
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词列表
- en: The following function downloads a list of about 100,000 words in American English.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数下载了大约10万个美国英语单词的列表。
- en: '[PRE45]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The file contains one word per line, so we can read the file and split it into
    a list of words like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 文件每行包含一个单词，所以我们可以读取文件并将其拆分成一个单词列表，就像这样：
- en: '[PRE46]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Exercise:** Write a loop that iterates through this word list and prints
    only words'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：编写一个循环，遍历这个单词列表，并只打印单词
- en: With at least four letters,
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少有四个字母，
- en: That can be spelled using only the letters `dehiklo`, and
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能使用字母`dehiklo`拼写，和
- en: That include the letter `o`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括字母`o`。
- en: '**Exercise:** Now let’s check for pangrams. Write a function called `uses_all`
    that takes two strings and returns `True` if the first string uses all of the
    letters in the second string. Think about how to express this computation using
    set operations.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：现在让我们检查全字母句。编写一个名为`uses_all`的函数，它接受两个字符串，并在第一个字符串使用第二个字符串的所有字母时返回`True`。思考如何使用集合操作来表达这个计算。
- en: Test your function with at least one case that returns `True` and one that returns
    `False`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用至少一个返回`True`和一个返回`False`的案例测试你的函数。
- en: '**Exercise:** Modify the previous loop to search the word list for pangrams
    using `uses_only` and `uses_all`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 练习：修改前面的循环，使用`uses_only`和`uses_all`在单词列表中搜索全字母句。
- en: Or, as a bonus, write a function called `uses_all_and_only` that checks both
    conditions using a single `set` operation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为奖励，编写一个名为`uses_all_and_only`的函数，使用单个`set`操作检查这两个条件。
- en: Leftovers
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剩余部分
- en: So far we’ve been writing Boolean functions that test specific conditions, but
    if they return `False`, they don’t explain why. As an alternative to `uses_only`,
    we could write a function called `bad_letters` that takes a word and a set of
    letters, and returns a new string that contains the letters in words that are
    not available. Let’s call it `bad_letters`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在编写测试特定条件的布尔函数，但如果它们返回`False`，它们不会解释原因。作为`uses_only`的替代方案，我们可以编写一个名为`bad_letters`的函数，该函数接受一个单词和一组字母，并返回一个新字符串，其中包含单词中不可用的字母。让我们称它为`bad_letters`。
- en: '[PRE48]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now if we run this function with an illegal word, it will tell us which letters
    in the word are not available.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用一个非法单词运行这个函数，它会告诉我们单词中哪些字母是不可用的。
- en: '[PRE49]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Exercise:** Write a function called `unused_letters` that takes a word and
    a set of letters and returns the subset of the letters that are not used in `word`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：**编写一个名为`unused_letters`的函数，该函数接受一个单词和一组字母，并返回在`word`中未使用的字母的子集。'
- en: '**Exercise:** Write a function called `no_duplicates` that takes a string and
    returns `True` if each letter appears only once.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：**编写一个名为`no_duplicates`的函数，该函数接受一个字符串并返回`True`，如果每个字母只出现一次。'
- en: '*Data Structures and Information Retrieval in Python*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的数据结构和信息检索
- en: Copyright 2021 Allen Downey
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 2021 Allen Downey
- en: 'License: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 许可证：[知识共享署名-非商业性使用-相同方式共享4.0国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)
